{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to PyPDFForm","text":"<p>PyPDFForm is a Python library for PDF form processing. It contains the essential functionalities needed to interact with PDF forms:</p> <ul> <li>Inspect what data a PDF form needs to be filled with.</li> <li>Fill a PDF form by simply creating a Python dictionary.</li> <li>Create form fields on a PDF.</li> </ul> <p>It also supports other common utilities such as extracting pages and merging multiple PDFs together.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Here's a quick look at how PyPDFForm works:</p> InstallInstantiateCreateInspectStyleFillSave <pre><code>pip install PyPDFForm\n</code></pre> <pre><code>from PyPDFForm import BlankPage, PdfWrapper\n\npdf = PdfWrapper(BlankPage())\n</code></pre> <pre><code>from PyPDFForm import Fields, RawElements\n\npdf.draw([\n    RawElements.RawText(\"My Textfield:\", 1, 100, 600),\n    RawElements.RawText(\"My Checkbox:\", 1, 100, 550),\n])\npdf.bulk_create_fields([\n    Fields.TextField(\"my_textfield\", 1, 180, 596, height=16),\n    Fields.CheckBoxField(\"my_checkbox\", 1, 180, 546, size=16),\n])\n</code></pre> <pre><code>from pprint import pprint\n\npprint(pdf.schema)\n</code></pre> <pre><code>pdf.widgets[\"my_textfield\"].font_color = (1, 0, 0)\npdf.widgets[\"my_textfield\"].alignment = 1\n</code></pre> <pre><code>pdf.fill({\n    \"my_textfield\": \"this is a text field\",\n    \"my_checkbox\": True,\n})\n</code></pre> <pre><code>pdf.write(\"output.pdf\")\n</code></pre>"},{"location":"#whats-next","title":"What's next?","text":"<ul> <li> Read the User Guide for detailed usage guides.</li> <li> Read the Developer Guide if you want to contribute.</li> <li> Submit GitHub Issues to report bugs.</li> <li> Star to support this project.</li> </ul>"},{"location":"acro_js/","title":"Embed PDF JavaScript","text":"Warning <p>Do NOT trust user input; always sanitize it. Although PDF JavaScript runs in a sandbox, arbitrary execution is dangerous and can lead to remote code execution vulnerabilities.</p> <p>This documentation uses this PDF as an example.</p> <p>PDFs can execute JavaScript during interactions if supported by the viewer. PyPDFForm provides APIs to embed scripts into both the PDF document and its form fields.</p> <p>For example, this snippet embeds a script that triggers an alert when the <code>test</code> field is hovered:</p> alert.jsFile PathFile ObjectFile Content <pre><code>app.alert(\"Hello World!\");\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template.pdf\")\nform.widgets[\"test\"].on_hovered_over_javascript = \"./alert.js\"\n\nform.write(\"output.pdf\")\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template.pdf\")\nform.widgets[\"test\"].on_hovered_over_javascript = open(\"./alert.js\")  # in practice, use a context manager\n\nform.write(\"output.pdf\")\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template.pdf\")\nform.widgets[\"test\"].on_hovered_over_javascript = open(\"./alert.js\").read()  # in practice, use a context manager\n\nform.write(\"output.pdf\")\n</code></pre> Tip <p>Please refer to this link for JavaScript that can be executed in PDF forms.</p>"},{"location":"acro_js/#execute-javascript-on-hover","title":"Execute JavaScript on hover","text":"<p>Set the <code>on_hovered_over_javascript</code> attribute to run code when a field is hovered over:</p> script.jsmain.py <pre><code>this.getField(\"test\").value = \"hovered over\";\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template.pdf\")\nform.widgets[\"test\"].on_hovered_over_javascript = \"./script.js\"\n\nform.write(\"output.pdf\")\n</code></pre>"},{"location":"acro_js/#execute-javascript-on-hover-off","title":"Execute JavaScript on hover off","text":"<p>Set the <code>on_hovered_off_javascript</code> attribute to run code when the mouse moves away from a field:</p> script.jsmain.py <pre><code>this.getField(\"test\").value = \"hovered off\";\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template.pdf\")\nform.widgets[\"test\"].on_hovered_off_javascript = \"./script.js\"\n\nform.write(\"output.pdf\")\n</code></pre>"},{"location":"acro_js/#execute-javascript-on-mouse-pressed","title":"Execute JavaScript on mouse pressed","text":"<p>Set the <code>on_mouse_pressed_javascript</code> attribute to run code when a mouse button is pressed within a field:</p> script.jsmain.py <pre><code>this.getField(\"test\").value = \"mouse pressed\";\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template.pdf\")\nform.widgets[\"test\"].on_mouse_pressed_javascript = \"./script.js\"\n\nform.write(\"output.pdf\")\n</code></pre>"},{"location":"acro_js/#execute-javascript-on-mouse-released","title":"Execute JavaScript on mouse released","text":"<p>Set the <code>on_mouse_released_javascript</code> attribute to run code when a mouse button is released within a field:</p> script.jsmain.py <pre><code>this.getField(\"test\").value = \"mouse released\";\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template.pdf\")\nform.widgets[\"test\"].on_mouse_released_javascript = \"./script.js\"\n\nform.write(\"output.pdf\")\n</code></pre>"},{"location":"acro_js/#execute-javascript-on-focus","title":"Execute JavaScript on focus","text":"<p>Set the <code>on_focused_javascript</code> attribute to run code when a field gains focus:</p> script.jsmain.py <pre><code>this.getField(\"test\").value = \"focused\";\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template.pdf\")\nform.widgets[\"test\"].on_focused_javascript = \"./script.js\"\n\nform.write(\"output.pdf\")\n</code></pre>"},{"location":"acro_js/#execute-javascript-on-blur","title":"Execute JavaScript on blur","text":"<p>Set the <code>on_blurred_javascript</code> attribute to run code when a field loses focus:</p> script.jsmain.py <pre><code>this.getField(\"test\").value = \"not focused\";\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template.pdf\")\nform.widgets[\"test\"].on_blurred_javascript = \"./script.js\"\n\nform.write(\"output.pdf\")\n</code></pre>"},{"location":"acro_js/#execute-javascript-on-pdf-open","title":"Execute JavaScript on PDF open","text":"<p>The <code>PdfWrapper.on_open_javascript</code> property sets or retrieves the script executed when the PDF opens:</p> script.jsmain.py <pre><code>this.getField(\"test\").value = \"opened\";\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template.pdf\")\nform.on_open_javascript = \"./script.js\"\nprint(form.on_open_javascript)\n\nform.write(\"output.pdf\")\n</code></pre>"},{"location":"annotation/","title":"Annotate PDFs","text":"<p>PyPDFForm supports adding non-form-field annotations to PDFs.</p> <p>This section uses this PDF as an example.</p> <p>Understanding the PDF coordinate system is necessary for this section.</p> <p>Optional parameters are marked with an <code># optional</code> comment.</p>"},{"location":"annotation/#create-text-annotations","title":"Create text annotations","text":"<p>Text annotations appear as sticky notes on a PDF. To create them, use the <code>PdfWrapper.annotate</code> method and pass a list of annotations:</p> <pre><code>from PyPDFForm import Annotations, PdfWrapper\n\nannotations = [\n    Annotations.TextAnnotation(\n        page_number=1,\n        x=310,\n        y=663,\n        contents=\"this is an annotation\",  # optional\n        title=\"First Annotation\",  # optional\n    ),\n    Annotations.TextAnnotation(\n        page_number=2,\n        x=310,\n        y=672,\n        contents=\"this is another annotation\",  # optional\n        title=\"Second Annotation\",  # optional\n        icon=Annotations.TextAnnotation.comment_icon,  # optional (1)\n    ),\n]\n\npdf = PdfWrapper(\"sample_template.pdf\").annotate(annotations)\n\npdf.write(\"output.pdf\")\n</code></pre> <ol> <li>Default is <code>note_icon</code>. Other options are <code>comment_icon</code>, <code>help_icon</code>, <code>key_icon</code>, and <code>insert_icon</code>.</li> </ol>"},{"location":"coordinate/","title":"PDF coordinate system","text":"<p>The PDF coordinate system originates at the bottom left of the page. The unit of measurement is \"points,\" with 72 points per inch. PyPDFForm uses this coordinate system in its APIs to create fields, text, and images on a PDF.</p>"},{"location":"coordinate/#generate-a-coordinate-grid-view","title":"Generate a coordinate grid view","text":"<p>To enhance the user experience with the coordinate system, PyPDFForm provides a grid view that helps determine the optimal placement of elements on a PDF.</p> <p>To generate a coordinate grid view for this PDF, use the following code:</p> <pre><code>from PyPDFForm import PdfWrapper\n\ngrid_view_pdf = PdfWrapper(\"sample_template.pdf\").generate_coordinate_grid(\n    color=(1, 0, 0),    # optional\n    margin=100  # optional\n)\n\ngrid_view_pdf.write(\"output.pdf\")\n</code></pre> <p>The <code>generate_coordinate_grid</code> method accepts two optional parameters: <code>color</code> and <code>margin</code>. The <code>color</code> parameter sets the grid view color (defaulting to red), and the <code>margin</code> parameter adjusts the coordinate grid view's margin in points (defaulting to 100 points).</p>"},{"location":"coordinate/#inspect-form-field-coordinates-dimensions","title":"Inspect form field coordinates &amp; dimensions","text":"<p>You can inspect the coordinates and dimensions of a PDF form field's rectangular bounding box by accessing its widget object:</p> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template.pdf\")\n\nprint(form.widgets[\"test\"].x)\nprint(form.widgets[\"test\"].y)\nprint(form.widgets[\"test\"].width)\nprint(form.widgets[\"test\"].height)\n</code></pre>"},{"location":"dev_changes/","title":"Pull Request Requirements","text":"<p>When submitting a pull request, follow these guidelines for a smooth review process.</p>"},{"location":"dev_changes/#code-changes","title":"Code changes","text":"<p>PyPDFForm welcomes contributions from developers of all levels and doesn't enforce strict coding rules.</p> <p>That said, your PR should follow these conventions:</p> <ul> <li>Try to submit small, incremental changes. For large changes, request a feature branch in your issue and open your PR against that branch, as they will likely need revision before merging into master.</li> <li>Ensure your changes pass all linters. PyPDFForm uses rules from pylint, ruff, and pyright. Run <code>linting</code> inside the development container to check.</li> <li>Your changes must pass all tests and have 100% coverage. You can read more about testing here.</li> <li>If you are changing the user APIs or any other parts of the code that are relevant, please update the appropriate documentation too.</li> </ul>"},{"location":"dev_changes/#merge-process","title":"Merge process","text":"<p>Your PR will be reviewed before merging into the master branch. If your changes are too extensive for inline comments, you may need to reopen your PR against a new feature branch for revision.</p> <p>Additionally, your PR must pass these CI checks:</p> <ul> <li>Linting on the source code.</li> <li>Tests will be run on three mainstream operating systems: <code>ubuntu</code>, <code>windows</code>, and <code>macos</code>, and across all Python versions the library supports on each OS.</li> </ul> <p>Once the CI is green and your code looks good, the PR will be merged into the master branch. They will be deployed on the next release.</p>"},{"location":"dev_doc/","title":"Hosting Docs Locally","text":"<p>When making changes to user APIs or other significant parts of the code, it's important to also update the relevant documentation.</p> <p>PyPDFForm uses MkDocs to build its documentation. You can either host it locally in a virtual environment or run it in the development container.</p> Virtual EnvironmentDevelopment Container <p>To host the documentation locally, run: <pre><code>mkdocs serve -a 0.0.0.0:8080\n</code></pre></p> <p>Alternatively, to run the documentation in the development container: <pre><code>docs\n</code></pre></p> <p>The documentation will be available at http://localhost:8080/.</p>"},{"location":"dev_intro/","title":"Developer Intro","text":"<p>PyPDFForm is a library built with Python. This part of the documentation is specifically for those who want to contribute to the project's development.</p>"},{"location":"dev_intro/#setup","title":"Setup","text":"Virtual EnvironmentDevelopment Container <p>To get started, create a virtual environment and install the development dependencies using your preferred package manager.</p> <p>The command below uses uv:</p> <pre><code>uv pip install -U -r pyproject.toml --extra dev\n</code></pre> <p>PyPDFForm also offers a development container. To build it, run the following command in the project's root directory:</p> <pre><code>docker build -t pypdfform-dev .\n</code></pre> <p>Once successfully built, you can open a shell inside the container by running:</p> <pre><code>docker run -it --rm -p 8000:8000 -p 8080:8080 -v .:/pypdfform pypdfform-dev\n</code></pre>"},{"location":"dev_intro/#running-tests","title":"Running tests","text":"<p>See testing PyPDFForm with pytest.</p>"},{"location":"dev_intro/#creating-issues","title":"Creating issues","text":"<p>When creating a GitHub issue, follow these guidelines:</p> <ul> <li>The issue title should have the format <code>PPF-&lt;issue number&gt;: &lt;title of the issue&gt;</code>.</li> <li>The issue description should be as descriptive as possible, preferably with the following:<ul> <li>A code snippet related to the issue.</li> <li>A PDF form template used by the code snippet.</li> <li>Screenshots that can help visualize the issue.</li> </ul> </li> </ul>"},{"location":"dev_intro/#opening-pull-requests","title":"Opening pull requests","text":"<p>Before opening a pull request, create an issue. When opening the pull request, follow these guidelines:</p> <ul> <li>The PR title should be the same as its respective issue, so <code>PPF-&lt;issue number&gt;: &lt;title of the issue&gt;</code>.</li> <li>The PR description should contain a brief explanation of the changes.</li> <li>Once opened, the PR should be linked to its respective issue.</li> </ul>"},{"location":"dev_release/","title":"Releasing","text":"<p>The PyPDFForm release process involves these initial steps:</p> <ol> <li>A version bump commit that runs black and isort on the codebase.</li> <li>A new GitHub release with auto-generated changelogs.</li> </ol> <p>These steps trigger the deployment CI.</p>"},{"location":"dev_release/#versioning","title":"Versioning","text":"<p>PyPDFForm follows Semantic Versioning.</p> <p>Documentation versioning follows a slightly different strategy, tracking only major and minor versions. For example, a release of <code>v1.2.3</code> updates the documentation for <code>v1.2</code>, whereas a release of <code>v1.3.0</code> creates documentation for <code>v1.3</code>.</p>"},{"location":"dev_release/#deploy-process","title":"Deploy process","text":"<p>A GitHub release triggers two CIs:</p> <ul> <li>Deploy, which creates the distribution and uploads it to PyPI.</li> <li>Deploy Docs, which updates the doc site or creates a new version for minor/major releases.</li> </ul>"},{"location":"dev_release/#when-are-releases-done","title":"When are releases done?","text":"<p>Release timing depends on changes pending deployment on the master branch. Generally:</p> <ul> <li>Serious bugs are usually released immediately after they are fixed.</li> <li>New features can usually wait and are released on a weekly basis.</li> <li>Trivial changes are usually bundled with other changes and can wait indefinitely.</li> </ul>"},{"location":"dev_test/","title":"Testing","text":"<p>PyPDFForm uses pytest for testing and coverage.py for measuring test coverage. To run the tests, execute:</p> Virtual EnvironmentDevelopment Container <pre><code>coverage run -m pytest &amp;&amp; coverage report --fail-under=100\n</code></pre> <pre><code>test\n</code></pre>"},{"location":"dev_test/#generate-coverage-report","title":"Generate coverage report","text":"<p>To generate a test coverage report, run:</p> Virtual EnvironmentDevelopment Container <pre><code>coverage run -m pytest &amp;&amp; coverage html\n</code></pre> <p>View the coverage report by opening <code>htmlcov/index.html</code> in a browser.</p> <pre><code>coverage\n</code></pre> <p>View the coverage report at http://localhost:8000/htmlcov/index.html.</p>"},{"location":"dev_test/#test-breakdown","title":"Test breakdown","text":"<p>Although each PyPDFForm test is unique, most follow a general paradigm.</p> <p>Most tests can be summarized into three steps:</p> <ul> <li>Define an expected PDF file that the outcome of the test should look like.</li> <li>Execute a sequence of code using PyPDFForm to generate a PDF that should look like the expected PDF file.</li> <li>Compare the PDF generated by the test with the expected PDF file.</li> </ul> <p>Consider this example test:</p> <pre><code>def test_fill(pdf_samples, request):\n    expected_path = os.path.join(pdf_samples, \"sample_filled.pdf\")\n    with open(expected_path, \"rb+\") as f:\n        obj = PdfWrapper(\n            os.path.join(pdf_samples, \"sample_template.pdf\")\n        ).fill(\n            {\n                \"test\": \"test_1\",\n                \"check\": True,\n                \"test_2\": \"test_2\",\n                \"check_2\": False,\n                \"test_3\": \"test_3\",\n                \"check_3\": True,\n            },\n        )\n\n        request.config.results[\"expected_path\"] = expected_path\n        request.config.results[\"stream\"] = obj.read()\n\n        expected = f.read()\n\n        assert len(obj.read()) == len(expected)\n        assert obj.read() == expected\n</code></pre> <p>The test starts by defining an expected PDF <code>sample_filled.pdf</code>:</p> <pre><code>expected_path = os.path.join(pdf_samples, \"sample_filled.pdf\")\n</code></pre> <p>The test then fills <code>sample_template.pdf</code> with a data dictionary using <code>PdfWrapper</code>:</p> <pre><code>obj = PdfWrapper(\n    os.path.join(pdf_samples, \"sample_template.pdf\")\n).fill(\n    {\n        \"test\": \"test_1\",\n        \"check\": True,\n        \"test_2\": \"test_2\",\n        \"check_2\": False,\n        \"test_3\": \"test_3\",\n        \"check_3\": True,\n    },\n)\n</code></pre> <p>Include these two lines in most tests to simplify updating old tests:</p> <pre><code>request.config.results[\"expected_path\"] = expected_path\nrequest.config.results[\"stream\"] = obj.read()\n</code></pre> <p>Finally, the test compares the resulted stream from the test with the expected file stream:</p> <pre><code>expected = f.read()\n\nassert len(obj.read()) == len(expected)\nassert obj.read() == expected\n</code></pre>"},{"location":"draw/","title":"Draw elements","text":"<p>PyPDFForm enables you to draw elements on a PDF, which is useful when a field is missing from your PDF form or when you need to add text or images.</p> <p>This section of the documentation uses this PDF as an example.</p> <p>Understanding the PDF coordinate system is necessary for this section.</p> <p>All optional parameters will have a comment <code># optional</code> after each of them.</p>"},{"location":"draw/#draw-text","title":"Draw text","text":"<p>When drawing multiple elements, it is more performant to create a list of those elements and draw them in a single operation.</p> <pre><code>from PyPDFForm import PdfWrapper, RawElements\n\ntexts = [\n    RawElements.RawText(\n        text=\"random text\",\n        page_number=1,\n        x=300,\n        y=225,\n        font=\"your_registered_font\",  # optional (1)\n        font_size=12,  # optional\n        font_color=(1, 0, 0),  # optional\n    ),\n    RawElements.RawText(\n        text=\"random text on page 2\",\n        page_number=2,\n        x=300,\n        y=225,\n        font=\"your_registered_font\",  # optional (2)\n        font_size=12,  # optional\n        font_color=(1, 0, 0),  # optional\n    ),\n]\n\npdf = PdfWrapper(\"sample_template.pdf\").draw(texts)\n\npdf.write(\"output.pdf\")\n</code></pre> <ol> <li>To use a custom font, see how to register it here.</li> <li>To use a custom font, see how to register it here.</li> </ol>"},{"location":"draw/#draw-image","title":"Draw image","text":"<p>For the <code>rotation</code> parameter, a positive value rotates the image counter-clockwise, and a negative value rotates it clockwise.</p> File PathOpen File ObjectBytes File Stream <pre><code>from PyPDFForm import PdfWrapper, RawElements\n\nimages = [\n    RawElements.RawImage(\n        image=\"sample_image.jpg\",\n        page_number=1,\n        x=100,\n        y=100,\n        width=400,\n        height=225,\n        rotation=0,  # optional\n    ),\n    RawElements.RawImage(\n        image=\"sample_image.jpg\",\n        page_number=2,\n        x=100,\n        y=100,\n        width=400,\n        height=225,\n        rotation=180,  # optional\n    ),\n]\n\npdf = PdfWrapper(\"sample_template.pdf\").draw(images)\n\npdf.write(\"output.pdf\")\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper, RawElements\n\nimages = [\n    RawElements.RawImage(\n        image=open(\"sample_image.jpg\", \"rb+\"),  # in practice, use a context manager\n        page_number=1,\n        x=100,\n        y=100,\n        width=400,\n        height=225,\n        rotation=0,  # optional\n    ),\n    RawElements.RawImage(\n        image=open(\"sample_image.jpg\", \"rb+\"),  # in practice, use a context manager\n        page_number=2,\n        x=100,\n        y=100,\n        width=400,\n        height=225,\n        rotation=180,  # optional\n    ),\n]\n\npdf = PdfWrapper(\"sample_template.pdf\").draw(images)\n\npdf.write(\"output.pdf\")\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper, RawElements\n\nimages = [\n    RawElements.RawImage(\n        image=open(\"sample_image.jpg\", \"rb+\").read(),  # in practice, use a context manager\n        page_number=1,\n        x=100,\n        y=100,\n        width=400,\n        height=225,\n        rotation=0,  # optional\n    ),\n    RawElements.RawImage(\n        image=open(\"sample_image.jpg\", \"rb+\").read(),  # in practice, use a context manager\n        page_number=2,\n        x=100,\n        y=100,\n        width=400,\n        height=225,\n        rotation=180,  # optional\n    ),\n]\n\npdf = PdfWrapper(\"sample_template.pdf\").draw(images)\n\npdf.write(\"output.pdf\")\n</code></pre>"},{"location":"draw/#draw-line","title":"Draw line","text":"<p>A line can be drawn by specifying starting and ending coordinates, and optionally its color.</p> <pre><code>from PyPDFForm import PdfWrapper, RawElements\n\nlines = [\n    RawElements.RawLine(\n        page_number=1,\n        src_x=100,\n        src_y=100,\n        dest_x=100,\n        dest_y=200,\n    ),\n    RawElements.RawLine(\n        page_number=1,\n        src_x=100,\n        src_y=100,\n        dest_x=200,\n        dest_y=100,\n        color=(0, 0, 1),  # optional\n    ),\n]\n\npdf = PdfWrapper(\"sample_template.pdf\").draw(lines)\n\npdf.write(\"output.pdf\")\n</code></pre>"},{"location":"draw/#draw-rectangle","title":"Draw rectangle","text":"<p>A rectangle can be drawn by specifying its coordinates and dimensions, and optionally its color and fill color.</p> <pre><code>from PyPDFForm import PdfWrapper, RawElements\n\nrectangles = [\n    RawElements.RawRectangle(\n        page_number=1,\n        x=100,\n        y=100,\n        width=200,\n        height=100,\n    ),\n    RawElements.RawRectangle(\n        page_number=1,\n        x=400,\n        y=100,\n        width=100,\n        height=200,\n        color=(0, 0, 1),  # optional\n        fill_color=(0, 1, 0),  # optional\n    ),\n]\n\npdf = PdfWrapper(\"sample_template.pdf\").draw(rectangles)\n\npdf.write(\"output.pdf\")\n</code></pre>"},{"location":"draw/#draw-circle","title":"Draw circle","text":"<p>A circle can be drawn by specifying its center coordinates and radius, and optionally its color and fill color.</p> <pre><code>from PyPDFForm import PdfWrapper, RawElements\n\ncircles = [\n    RawElements.RawCircle(\n        page_number=1,\n        center_x=100,\n        center_y=100,\n        radius=50,\n    ),\n    RawElements.RawCircle(\n        page_number=1,\n        center_x=250,\n        center_y=100,\n        radius=100,\n        color=(1, 0, 0),  # optional\n        fill_color=(0, 1, 0),  # optional\n    ),\n]\n\npdf = PdfWrapper(\"sample_template.pdf\").draw(circles)\n\npdf.write(\"output.pdf\")\n</code></pre>"},{"location":"draw/#draw-ellipse","title":"Draw ellipse","text":"<p>An ellipse can be drawn by specifying its bounding box coordinates, and optionally its color and fill color.</p> <pre><code>from PyPDFForm import PdfWrapper, RawElements\n\nellipses = [\n    RawElements.RawEllipse(\n        page_number=1,\n        x1=100,\n        y1=100,\n        x2=250,\n        y2=200,\n    ),\n    RawElements.RawEllipse(\n        page_number=1,\n        x1=300,\n        y1=100,\n        x2=500,\n        y2=250,\n        color=(1, 0, 0),  # optional\n        fill_color=(0, 1, 0),  # optional\n    ),\n]\n\npdf = PdfWrapper(\"sample_template.pdf\").draw(ellipses)\n\npdf.write(\"output.pdf\")\n</code></pre>"},{"location":"fill/","title":"Fill PDF forms","text":"<p>PyPDFForm fills a PDF form using a flat, non-nested dictionary. The filled form is editable by default. When you call the <code>fill</code> method, you can set the optional parameter <code>flatten</code> to <code>True</code> to flatten the filled form, making it uneditable.</p>"},{"location":"fill/#fill-text-field-and-checkbox","title":"Fill text field and checkbox","text":"<p>To fill a text field, provide a <code>string</code> value, and for a checkbox, use a <code>boolean</code> value. The following example demonstrates how to fill this PDF:</p> <pre><code>from PyPDFForm import PdfWrapper\n\nfilled = PdfWrapper(\"sample_template.pdf\").fill(\n    {\n        \"test\": \"test_1\",\n        \"check\": True,\n        \"test_2\": \"test_2\",\n        \"check_2\": False,\n        \"test_3\": \"test_3\",\n        \"check_3\": True,\n    },\n    flatten=False   # optional, set to True to flatten the filled PDF form\n)\n\nfilled.write(\"output.pdf\")\n</code></pre>"},{"location":"fill/#fill-radio-button-group","title":"Fill radio button group","text":"<p>A radio button group is a collection of radio buttons sharing the same name on a PDF form.</p> <p>A PDF form with radio button groups can be filled using <code>integer</code> values, where the value indicates which radio button to select within each group:</p> <pre><code>from PyPDFForm import PdfWrapper\n\nfilled = PdfWrapper(\"sample_template_with_radio_button.pdf\").fill(\n    {\n        \"radio_1\": 0,\n        \"radio_2\": 1,\n        \"radio_3\": 2,\n    },\n    flatten=False   # optional, set to True to flatten the filled PDF form\n)\n\nfilled.write(\"output.pdf\")\n</code></pre>"},{"location":"fill/#fill-dropdown-field","title":"Fill dropdown field","text":"<p>As with radio buttons, a dropdown choice can be selected by specifying its <code>integer</code> value. For example, to fill this PDF:</p> Using Option IndexUsing String Value <pre><code>from PyPDFForm import PdfWrapper\n\nfilled = PdfWrapper(\"sample_template_with_dropdown.pdf\").fill(\n    {\n        \"dropdown_1\": 1\n    },\n    flatten=False   # optional, set to True to flatten the filled PDF form\n)\n\nfilled.write(\"output.pdf\")\n</code></pre> <p>You can also specify a dropdown option by its <code>string</code> value:</p> <pre><code>from PyPDFForm import PdfWrapper\n\nfilled = PdfWrapper(\"sample_template_with_dropdown.pdf\").fill(\n    {\n        \"dropdown_1\": \"bar\"\n    },\n    flatten=False   # optional, set to True to flatten the filled PDF form\n)\n\nfilled.write(\"output.pdf\")\n</code></pre> Note <p>If you fill a dropdown field with a <code>string</code> value that is not one of its existing options, the new value is added as the last option in the dropdown and automatically selected.</p>"},{"location":"fill/#fill-signature-field","title":"Fill signature field","text":"<p>A signature field enables signing a PDF form with a handwritten signature image.</p> <p>To fill a signature field, consider this PDF and this signature image:</p> File PathOpen File ObjectBytes File StreamAspect Ratio <pre><code>from PyPDFForm import PdfWrapper\n\nsigned = PdfWrapper(\"sample_template_with_signature.pdf\").fill(\n    {\n        \"signature\": \"sample_signature.png\"\n    },\n    flatten=False   # optional, set to True to flatten the filled PDF form\n)\n\nsigned.write(\"output.pdf\")\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\nwith open(\"sample_signature.png\", \"rb+\") as sig:\n    signed = PdfWrapper(\"sample_template_with_signature.pdf\").fill(\n        {\n            \"signature\": sig\n        },\n        flatten=False   # optional, set to True to flatten the filled PDF form\n    )\n\nsigned.write(\"output.pdf\")\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\nwith open(\"sample_signature.png\", \"rb+\") as sig:\n    signed = PdfWrapper(\"sample_template_with_signature.pdf\").fill(\n        {\n            \"signature\": sig.read()\n        },\n        flatten=False   # optional, set to True to flatten the filled PDF form\n    )\n\nsigned.write(\"output.pdf\")\n</code></pre> <p>By default, the library preserves the aspect ratio of the signature image when filling it. You can disable this by setting the <code>preserve_aspect_ratio</code> property to <code>False</code> on the signature field:</p> <pre><code>from PyPDFForm import PdfWrapper\n\npdf = PdfWrapper(\"sample_template_with_signature.pdf\")\npdf.widgets[\"signature\"].preserve_aspect_ratio = False\npdf.fill(\n    {\n        \"signature\": \"sample_signature.png\"\n    },\n)\n\npdf.write(\"output.pdf\")\n</code></pre>"},{"location":"fill/#fill-image-field","title":"Fill image field","text":"<p>Fill an image field similarly to a signature field, using a file path, file object, or file stream.</p> <p>To fill an image field, consider this PDF and this image:</p> File PathOpen File ObjectBytes File StreamAspect Ratio <pre><code>from PyPDFForm import PdfWrapper\n\nfilled = PdfWrapper(\"sample_template_with_image_field.pdf\").fill(\n    {\n        \"image_1\": \"sample_image.jpg\"\n    },\n    flatten=False   # optional, set to True to flatten the filled PDF form\n)\n\nfilled.write(\"output.pdf\")\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\nwith open(\"sample_image.jpg\", \"rb+\") as img:\n    filled = PdfWrapper(\"sample_template_with_image_field.pdf\").fill(\n        {\n            \"image_1\": img\n        },\n        flatten=False   # optional, set to True to flatten the filled PDF form\n    )\n\nfilled.write(\"output.pdf\")\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\nwith open(\"sample_image.jpg\", \"rb+\") as img:\n    filled = PdfWrapper(\"sample_template_with_image_field.pdf\").fill(\n        {\n            \"image_1\": img.read()\n        },\n        flatten=False   # optional, set to True to flatten the filled PDF form\n    )\n\nfilled.write(\"output.pdf\")\n</code></pre> <p>Unlike the signature field, the library does not preserve the aspect ratio of a regular image by default. You can enable this by setting the <code>preserve_aspect_ratio</code> property to <code>True</code> on the image field:</p> <pre><code>from PyPDFForm import PdfWrapper\n\npdf = PdfWrapper(\"sample_template_with_image_field.pdf\")\npdf.widgets[\"image_1\"].preserve_aspect_ratio = True\npdf.fill(\n    {\n        \"image_1\": \"sample_image.jpg\"\n    },\n)\n\npdf.write(\"output.pdf\")\n</code></pre>"},{"location":"font/","title":"Register fonts","text":"<p>PyPDFForm enables the use of custom fonts in certain APIs. To use a custom font, you must first register its TrueType (.ttf) file.</p> <p>For example, to use a font from the Liberation Serif family, register its TrueType file (e.g., LiberationSerif-BoldItalic.ttf) as follows:</p> File PathOpen File ObjectBytes File Stream <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template.pdf\")\nform.register_font(\"new_font_name\", \"LiberationSerif-BoldItalic.ttf\")\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template.pdf\")\nwith open(\"LiberationSerif-BoldItalic.ttf\", \"rb+\") as font_file:\n    form.register_font(\"new_font_name\", font_file)\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template.pdf\")\nwith open(\"LiberationSerif-BoldItalic.ttf\", \"rb+\") as font_file:\n    form.register_font(\"new_font_name\", font_file.read())\n</code></pre> <p>In this example, <code>LiberationSerif-BoldItalic.ttf</code> is registered as <code>new_font_name</code>. You can now reference this font in the object's APIs using the name <code>new_font_name</code>.</p>"},{"location":"font/#get-registered-fonts","title":"Get registered fonts","text":"<p>To see which fonts have been registered, access the <code>fonts</code> attribute of the <code>PdfWrapper</code> object:</p> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template.pdf\")\nform.register_font(\"new_font_name\", \"LiberationSerif-BoldItalic.ttf\")\n\nprint(form.fonts)\n</code></pre> <p>The <code>fonts</code> attribute lists the names of the registered fonts.</p>"},{"location":"inspect/","title":"Inspect form field data","text":"<p>Once a PDF form is prepared, PyPDFForm can help you inspect its fields to determine the data needed to fill it. Several inspection methods are available to choose from.</p> <p>This section of the documentation uses this PDF as an example.</p>"},{"location":"inspect/#generate-a-json-schema-that-describes-a-pdf-form","title":"Generate a JSON schema that describes a PDF form","text":"<p>You can describe the dictionary used to fill a PDF form using a JSON schema. For example:</p> CodeOutput <pre><code>import json\nfrom PyPDFForm import PdfWrapper\n\npdf_form_schema = PdfWrapper(\"sample_template.pdf\").schema\n\nprint(json.dumps(pdf_form_schema, indent=4, sort_keys=True))\n</code></pre> <pre><code>{\n    \"properties\": {\n        \"check\": {\n            \"type\": \"boolean\"\n        },\n        \"check_2\": {\n            \"type\": \"boolean\"\n        },\n        \"check_3\": {\n            \"type\": \"boolean\"\n        },\n        \"test\": {\n            \"type\": \"string\"\n        },\n        \"test_2\": {\n            \"type\": \"string\"\n        },\n        \"test_3\": {\n            \"type\": \"string\"\n        }\n    },\n    \"type\": \"object\"\n}\n</code></pre> <p>In this example, <code>sample_template.pdf</code> contains three text fields (<code>test</code>, <code>test_2</code>, and <code>test_3</code>) of type <code>string</code> and three checkboxes (<code>check</code>, <code>check_2</code>, and <code>check_3</code>) of type <code>boolean</code>.</p> <p>You can use the PyPDFForm-generated JSON schema to validate the data used for filling a PDF form.</p>"},{"location":"inspect/#inspect-pdf-form-data","title":"Inspect PDF form data","text":"<p>To inspect the current filled data of a PDF form, use the <code>.data</code> attribute. For example, the following snippet inspects the current filled data for this PDF:</p> CodeOutput <pre><code>from pprint import pprint\nfrom PyPDFForm import PdfWrapper\n\npprint(PdfWrapper(\"sample_template_filled.pdf\").data)\n</code></pre> <pre><code>{'check': True,\n'check_2': True,\n'check_3': True,\n'test': 'test',\n'test_2': 'test2',\n'test_3': 'test3'}\n</code></pre>"},{"location":"inspect/#generate-sample-data","title":"Generate sample data","text":"<p>PyPDFForm can also generate sample data for filling a PDF form:</p> CodeOutput <pre><code>from pprint import pprint\nfrom PyPDFForm import PdfWrapper\n\npprint(PdfWrapper(\"sample_template.pdf\").sample_data)\n</code></pre> <pre><code>{'check': True,\n'check_2': True,\n'check_3': True,\n'test': 'test',\n'test_2': 'test_2',\n'test_3': 'test_3'}\n</code></pre>"},{"location":"install/","title":"Installation and setup","text":"<p>PyPDFForm is available on PyPI and can be installed using any preferred package manager, such as pip, Poetry, or uv.</p>"},{"location":"install/#prerequisites","title":"Prerequisites","text":"<p>PyPDFForm officially supports Python 3.10 and newer versions that are currently in their active life cycles. This typically includes the minimum supported version and the four major versions above it. For details on Python version life cycles, refer to this page.</p>"},{"location":"install/#install-using-pip","title":"Install using pip","text":"<p>It is highly recommended to create a virtual environment before installation. Then, run the following command to install PyPDFForm:</p> InstallInstall &amp; Upgrade Dependencies <pre><code>pip install PyPDFForm\n</code></pre> <pre><code>pip install -U PyPDFForm\n</code></pre>"},{"location":"install/#create-a-pdf-wrapper","title":"Create a PDF wrapper","text":"<p>The main user interface of the library is the <code>PdfWrapper</code> class. It implements most PyPDFForm APIs and accepts various optional parameters, the most important of which is the PDF form template.</p> <p>For example, to use this PDF as a template, instantiate the <code>PdfWrapper</code> object as follows:</p> File PathOpen File ObjectBytes File Stream <pre><code>from PyPDFForm import PdfWrapper\n\npdf = PdfWrapper(\"sample_template.pdf\")\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\nwith open(\"sample_template.pdf\", \"rb+\") as template:\n    pdf = PdfWrapper(template)\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\nwith open(\"sample_template.pdf\", \"rb+\") as template:\n    pdf = PdfWrapper(template.read())\n</code></pre> Tip <p>PyPDFForm provides an adapter for different file interaction methods in Python, which allows you to pass your PDF form to <code>PdfWrapper</code> as a file path, an open file object, or a <code>bytes</code> file stream. This file adaptation applies to all PyPDFForm APIs. You can replace file path parameters with file objects or streams throughout the documentation.</p>"},{"location":"install/#change-pdf-title","title":"Change PDF title","text":"<p>The PDF title can be set during <code>PdfWrapper</code> instantiation or via the <code>.title</code> property. Accessing it retrieves the current title.</p> Instantiate with TitleSet Title via AttributeGet Title via Attribute <pre><code>from PyPDFForm import PdfWrapper\n\npdf = PdfWrapper(\"sample_template.pdf\", title=\"My PDF\")\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\npdf = PdfWrapper(\"sample_template.pdf\")\npdf.title = \"My PDF\"\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\npdf = PdfWrapper(\"sample_template.pdf\", title=\"My PDF\")\nprint(pdf.title)\n</code></pre>"},{"location":"install/#handling-appearance-streams","title":"Handling appearance streams","text":"<p>For a PDF viewer to display content in a form field (especially text fields), it needs an \"appearance stream.\" This stream defines how the field's content is rendered. PyPDFForm offers two ways to handle this, set via flags during <code>PdfWrapper</code> instantiation.</p> Let the Viewer Generate AppearancesLet PyPDFForm Generate Appearances <p>Set <code>need_appearances=True</code> to instruct the PDF viewer to generate appearance streams. This is often the best choice when you expect the PDF to be opened in powerful, proprietary software like Adobe Acrobat, which has sophisticated rendering capabilities.</p> <pre><code>from PyPDFForm import PdfWrapper\n\npdf = PdfWrapper(\"sample_template.pdf\", need_appearances=True)\n</code></pre> <p>Set <code>generate_appearance_streams=True</code> to use PyPDFForm's built-in generator. This is a good fallback if the PDF viewer lacks the ability to generate its own appearance streams.</p> <pre><code>from PyPDFForm import PdfWrapper\n\npdf = PdfWrapper(\"sample_template.pdf\", generate_appearance_streams=True)\n</code></pre> Warning <p>PyPDFForm's internal appearance stream generation relies on qpdf and shares its limitations. Some known limitations include:</p> <ul> <li>Limited to ASCII text: Only ASCII characters are supported.</li> <li>Single-line text fields only: It does not support multi-line text fields.</li> <li>No text alignment handling: Text alignment (left, center, right) is not preserved or applied.</li> </ul>"},{"location":"install/#handling-metadata","title":"Handling metadata","text":"Note <p>PDF metadata preservation must be enabled explicitly due to regressions identified in the test suites.</p> <p>To ensure the original metadata of a PDF template is maintained after performing operations with <code>PdfWrapper</code>, set the <code>preserve_metadata</code> parameter to <code>True</code> during instantiation:</p> <pre><code>from PyPDFForm import PdfWrapper\n\npdf = PdfWrapper(\"sample_template.pdf\", preserve_metadata=True)\n</code></pre>"},{"location":"install/#use-full-name-for-pdf-form-fields","title":"Use full name for PDF form fields","text":"<p>According to section 12.7.3.2 of the PDF standard, PDF form fields can have fully qualified names constructed using the pattern <code>&lt;parent_field_name&gt;.&lt;field_name&gt;</code>.</p> <p>PyPDFForm allows you to access fields by their full names by setting <code>use_full_widget_name</code> to <code>True</code> when instantiating <code>PdfWrapper</code>. For example, to use this PDF:</p> <pre><code>from PyPDFForm import PdfWrapper\n\npdf = PdfWrapper(\"sample_template_with_full_key.pdf\", use_full_widget_name=True)\n</code></pre> <p>This enables accessing fields by their full names. For instance, you can access the checkbox labeled <code>Gain de 2 classes</code> using its full name <code>Gain de 2 classes.0</code> instead of its partial name <code>0</code>.</p> Warning <p>When using full names, the <code>update_widget_key</code> and <code>commit_widget_key_updates</code> methods of <code>PdfWrapper</code> are disabled and raise a <code>NotImplementedError</code> because full names involve both the field and its parent.</p>"},{"location":"install/#write-to-a-file","title":"Write to a file","text":"<p>The <code>PdfWrapper</code> acts as a file-like object, enabling you to write the processed PDF to another file-like object:</p> Write to Disk FileWrite to Memory Buffer <pre><code>from PyPDFForm import PdfWrapper\n\npdf = PdfWrapper(\"sample_template.pdf\")\n\nwith open(\"output.pdf\", \"wb+\") as output:\n    output.write(pdf.read())\n</code></pre> <pre><code>from io import BytesIO\nfrom PyPDFForm import PdfWrapper\n\npdf = PdfWrapper(\"sample_template.pdf\")\n\nwith BytesIO() as output:\n    output.write(pdf.read())\n</code></pre> <p>Additionally, <code>PdfWrapper</code> offers a convenient <code>write</code> method to save the PDF directly.</p> Write to Disk FileWrite to Memory Buffer <pre><code>from PyPDFForm import PdfWrapper\n\npdf = PdfWrapper(\"sample_template.pdf\")\npdf.write(\"output.pdf\")\n</code></pre> <pre><code>from io import BytesIO\nfrom PyPDFForm import PdfWrapper\n\nbuff = BytesIO()\n\npdf = PdfWrapper(\"sample_template.pdf\")\npdf.write(buff)\n\nbuff.seek(0)\n</code></pre>"},{"location":"prepare/","title":"Create form fields","text":"<p>The most common tool for creating PDF form fields is Adobe Acrobat, and a tutorial is available here. Alternative free tools like DocFly offer similar functionality.</p> <p>PyPDFForm also allows creating PDF form fields on existing PDFs through coding.</p> <p>This section of the documentation will primarily use this PDF as an example.</p> <p>Understanding the PDF coordinate system is necessary for this section.</p> <p>All optional parameters will have a comment <code># optional</code> after each of them.</p>"},{"location":"prepare/#create-a-text-field","title":"Create a text field","text":"<p>A text field can be created by downloading the PDF and running the following snippet:</p> <pre><code>from PyPDFForm import Fields, PdfWrapper\n\nnew_form = PdfWrapper(\"dummy.pdf\").create_field(\n    Fields.TextField(\n        name=\"new_text_field\",\n        page_number=1,\n        x=57.5,\n        y=700.9,\n        required=False,  # optional\n        tooltip=\"this is a text field\",  # optional\n        width=120.3,  # optional\n        height=40.7,  # optional\n        max_length=5,  # optional, number of characters\n        comb=True,  # optional, when set to True, max_length must also be set (1)\n        font=\"your_registered_font\",  # optional (2)\n        font_size=15,  # optional\n        font_color=(1, 0, 0),  # optional\n        bg_color=(0, 0, 1, 1),  # optional, (r, g, b, alpha)\n        border_color=(1, 0, 0, 1),  # optional, (r, g, b, alpha)\n        border_width=5,  # optional\n        alignment=0,  # optional, 0=left, 1=center, 2=right\n        multiline=True,  # optional\n    )\n)\n\nnew_form.write(\"output.pdf\")\n</code></pre> <ol> <li>For the <code>comb</code> option, refer to the documentation here.</li> <li>To use a custom font, see how to register it here.</li> </ol>"},{"location":"prepare/#create-a-checkbox","title":"Create a checkbox","text":"<p>A checkbox can be created using the same method with some changes to the parameters:</p> <pre><code>from PyPDFForm import Fields, PdfWrapper\n\nnew_form = PdfWrapper(\"dummy.pdf\").create_field(\n    Fields.CheckBoxField(\n        name=\"new_checkbox\",\n        page_number=1,\n        x=57,\n        y=700,\n        required=False,  # optional\n        tooltip=\"this is a checkbox\",  # optional\n        size=30,  # optional\n        button_style=\"check\",  # optional (1)\n        tick_color=(0, 1, 0),  # optional\n        bg_color=(0, 0, 1, 1),  # optional, (r, g, b, alpha)\n        border_color=(1, 0, 0, 1),  # optional, (r, g, b, alpha)\n        border_width=5,  # optional\n    )\n)\n\nnew_form.write(\"output.pdf\")\n</code></pre> <ol> <li>The <code>button_style</code> parameter currently supports three options: <code>check</code>, <code>circle</code>, and <code>cross</code>.</li> </ol> Bug <p>To remove the border of a checkbox, set the alpha channel of the <code>border_color</code> to 0, for example: <code>border_color=(1, 0, 0, 0)</code>. Setting <code>border_width</code> to 0 may still render a border with a width of 1 due to a PDF specification quirk.</p>"},{"location":"prepare/#create-a-radio-button-group","title":"Create a radio button group","text":"<p>Unlike other field types, radio buttons must be created as a group. Therefore, for the coordinate parameters <code>x</code> and <code>y</code>, you must specify a list of coordinates for each radio button within the group, and the list must contain more than one coordinate.</p> <p>Otherwise, radio button creation shares almost the same parameters as a checkbox:</p> <pre><code>from PyPDFForm import Fields, PdfWrapper\n\nnew_form = PdfWrapper(\"dummy.pdf\").create_field(\n    Fields.RadioGroup(\n        name=\"new_radio_group\",\n        page_number=1,\n        x=[50, 100, 150],\n        y=[50, 100, 150],\n        required=False,  # optional\n        tooltip=\"this is a radio group\",  # optional\n        size=30,  # optional\n        button_style=\"check\",  # optional (1)\n        shape=\"square\",  # optional, circle or square\n        tick_color=(0, 1, 0),  # optional\n        bg_color=(0, 0, 1, 1),  # optional, (r, g, b, alpha)\n        border_color=(1, 0, 0, 1),  # optional, (r, g, b, alpha)\n        border_width=5,  # optional\n    )\n)\n\nnew_form.write(\"output.pdf\")\n</code></pre> <ol> <li>The <code>button_style</code> parameter currently supports three options: <code>check</code>, <code>circle</code>, and <code>cross</code>.</li> </ol> Bug <p>To remove the border of a group of radio buttons, set the alpha channel of the <code>border_color</code> to 0, for example: <code>border_color=(1, 0, 0, 0)</code>. Setting <code>border_width</code> to 0 may still render a border with a width of 1 due to a PDF specification quirk.</p>"},{"location":"prepare/#create-a-dropdown-field","title":"Create a dropdown field","text":"<p>A dropdown field shares a similar set of parameters as a text field. The only significant difference is that a list of <code>options</code> needs to be specified:</p> Default Export ValuesCustom Export Values <p><pre><code>from PyPDFForm import Fields, PdfWrapper\n\nnew_form = PdfWrapper(\"dummy.pdf\").create_field(\n    Fields.DropdownField(\n        name=\"new_dropdown\",\n        page_number=1,\n        x=57,\n        y=700,\n        options=[\n            \"foo\",\n            \"bar\",\n            \"foobar\",\n        ],\n        required=False,  # optional\n        tooltip=\"this is a dropdown\",  # optional\n        width=120,  # optional\n        height=40,  # optional\n        font=\"your_registered_font\",  # optional (1)\n        font_size=15,  # optional\n        font_color=(1, 0, 0),  # optional\n        bg_color=(0, 0, 1, 1),  # optional, (r, g, b, alpha)\n        border_color=(1, 0, 0, 1),  # optional, (r, g, b, alpha)\n        border_width=5,  # optional\n    )\n)\n\nnew_form.write(\"output.pdf\")\n</code></pre></p> <ol> <li>To use a custom font, see how to register it here.</li> </ol> <p>If you want different export values from the displayed options, you can specify a list of tuples for the <code>options</code> parameter, where the first value of each tuple is the displayed option and the second value is the export value:</p> <pre><code>from PyPDFForm import Fields, PdfWrapper\n\nnew_form = PdfWrapper(\"dummy.pdf\").create_field(\n    Fields.DropdownField(\n        name=\"new_dropdown\",\n        page_number=1,\n        x=57,\n        y=700,\n        options=[\n            (\"option_1\", \"option_1_export_value\"),\n            (\"option_2\", \"option_2_export_value\"),\n            (\"option_3\", \"option_3_export_value\"),\n        ],\n    )\n)\n\nnew_form.write(\"output.pdf\")\n</code></pre>"},{"location":"prepare/#create-a-signature-field","title":"Create a signature field","text":"<p>A signature field is only interactive in tools that support it. Otherwise, it is displayed as a rectangle, and clicking it will not trigger any action:</p> <pre><code>from PyPDFForm import Fields, PdfWrapper\n\nnew_form = PdfWrapper(\"dummy.pdf\").create_field(\n    Fields.SignatureField(\n        name=\"new_signature\",\n        page_number=1,\n        x=100,\n        y=100,\n        required=False,  # optional\n        tooltip=\"this is a signature\",  # optional\n        width=410,  # optional\n        height=100,  # optional\n    )\n)\n\nnew_form.write(\"output.pdf\")\n</code></pre>"},{"location":"prepare/#create-an-image-field","title":"Create an image field","text":"<p>Similar to a signature field, an image field is also only interactive in tools that support it:</p> <pre><code>from PyPDFForm import Fields, PdfWrapper\n\nnew_form = PdfWrapper(\"dummy.pdf\").create_field(\n    Fields.ImageField(\n        name=\"new_image\",\n        page_number=1,\n        x=100,\n        y=100,\n        required=False,  # optional\n        tooltip=\"this is an image\",  # optional\n        width=192,  # optional\n        height=108,  # optional\n    )\n)\n\nnew_form.write(\"output.pdf\")\n</code></pre>"},{"location":"prepare/#bulk-create-fields","title":"Bulk create fields","text":"<p>The <code>bulk_create_fields</code> method is more performant than creating fields one by one with the <code>create_field</code> method, especially when dealing with a large number of fields:</p> <pre><code>from PyPDFForm import Fields, PdfWrapper\n\nfields = [\n    Fields.TextField(\n        name=\"new_text_field_1\",\n        page_number=1,\n        x=100,\n        y=100,\n    ),\n    Fields.TextField(\n        name=\"new_text_field_2\",\n        page_number=1,\n        x=100,\n        y=300,\n    ),\n    Fields.CheckBoxField(\n        name=\"new_checkbox_1\",\n        page_number=1,\n        x=300,\n        y=100,\n    ),\n    Fields.CheckBoxField(\n        name=\"new_checkbox_2\",\n        page_number=1,\n        x=300,\n        y=300,\n    ),\n]\n\nnew_form = PdfWrapper(\"dummy.pdf\").bulk_create_fields(fields)\nnew_form.write(\"output.pdf\")\n</code></pre>"},{"location":"prepare/#modify-the-key-of-a-field","title":"Modify the key of a field","text":"<p>PyPDFForm allows you to modify the keys of existing fields.</p> Single UpdateUsing Index for Fields with Same KeyBulk Updates <p>For example, to change the key of the first text field, <code>test</code>, to <code>test_text</code> using this PDF, use the following code:</p> <pre><code>from PyPDFForm import PdfWrapper\n\nnew_form = PdfWrapper(\"sample_template.pdf\").update_widget_key(\n    \"test\", \"test_text\"\n)\n\nnew_form.write(\"output.pdf\")\n</code></pre> <p>If multiple fields share the same key, use the <code>index</code> parameter to specify which one to update. For instance, to change the key of the second row's text field with the key <code>Description[0]</code> to <code>Description[1]</code> using this PDF, use the following code:</p> <pre><code>from PyPDFForm import PdfWrapper\n\nnew_form = PdfWrapper(\"733.pdf\").update_widget_key(\n    \"Description[0]\", \"Description[1]\", index=1\n)\n\nnew_form.write(\"output.pdf\")\n</code></pre> <p>To improve performance for bulk updates, you can set <code>defer=True</code> on each key update. This stages the change without immediately applying it. A final call to <code>commit_widget_key_updates()</code> will then apply all staged changes at once.</p> <p>To change the key of each row's text field with the key <code>Description[0]</code> to <code>Description[i]</code>, where <code>i</code> is the index of each row, using this PDF, use the following code:</p> <pre><code>from PyPDFForm import PdfWrapper\n\nnew_form = PdfWrapper(\"733.pdf\")\n\nfor i in range(1, 10):\n    new_form.update_widget_key(\n        \"Description[0]\", f\"Description[{i}]\", index=1, defer=True\n    )\n\nnew_form.commit_widget_key_updates().write(\"output.pdf\")\n</code></pre>"},{"location":"style/","title":"Change form field styles","text":"<p>PyPDFForm enables you to modify some field styles through code, allowing you to change field appearances without altering the PDF form template.</p> <p>This section of the documentation will primarily use this PDF as an example.</p>"},{"location":"style/#change-text-field-font","title":"Change text field font","text":"<p>Before changing a text field's font, you must first register the desired font.</p> <p>After registration, you can apply the registered font to any text field:</p> <pre><code>from PyPDFForm import PdfWrapper, Widgets\n\nform = PdfWrapper(\"sample_template.pdf\")\n\n# change globally by iterating each text field\nfor field in form.widgets.values():\n    if isinstance(field, Widgets.Text):\n        field.font = \"your_registered_font\"\n\n# or change at each field's widget level\nform.widgets[\"test\"].font = \"your_registered_font\"\n\nform.fill(\n    {\n        \"test\": \"test_1\",\n        \"check\": True,\n        \"test_2\": \"test_2\",\n        \"check_2\": False,\n        \"test_3\": \"test_3\",\n        \"check_3\": True,\n    },\n)\n\nform.write(\"output.pdf\")\n</code></pre>"},{"location":"style/#change-text-field-font-size","title":"Change text field font size","text":"<p>You can change the font size using a <code>float</code> value in PyPDFForm:</p> <pre><code>from PyPDFForm import PdfWrapper, Widgets\n\nform = PdfWrapper(\"sample_template.pdf\")\n\n# change globally by iterating each text field\nfor field in form.widgets.values():\n    if isinstance(field, Widgets.Text):\n        field.font_size = 20\n\n# or change at each field's widget level\nform.widgets[\"test\"].font_size = 30.5\n\nform.fill(\n    {\n        \"test\": \"test_1\",\n        \"check\": True,\n        \"test_2\": \"test_2\",\n        \"check_2\": False,\n        \"test_3\": \"test_3\",\n        \"check_3\": True,\n    },\n)\n\nform.write(\"output.pdf\")\n</code></pre>"},{"location":"style/#change-text-field-font-color","title":"Change text field font color","text":"<p>You can change the font color using an RGB <code>tuple</code>:</p> <pre><code>from PyPDFForm import PdfWrapper, Widgets\n\nform = PdfWrapper(\"sample_template.pdf\")\n\n# change globally by iterating each text field\nfor field in form.widgets.values():\n    if isinstance(field, Widgets.Text):\n        field.font_color = (1, 0, 0)\n\n# or change at each field's widget level\nform.widgets[\"test\"].font_color = (0.2, 0, 0.5)\n\nform.fill(\n    {\n        \"test\": \"test_1\",\n        \"check\": True,\n        \"test_2\": \"test_2\",\n        \"check_2\": False,\n        \"test_3\": \"test_3\",\n        \"check_3\": True,\n    },\n)\n\nform.write(\"output.pdf\")\n</code></pre>"},{"location":"style/#change-text-field-alignment","title":"Change text field alignment","text":"<p>You can change the alignment of the text filled into a text field by setting its <code>alignment</code> property to an integer value: <code>0</code> for left, <code>1</code> for center, and <code>2</code> for right.</p> <pre><code>from PyPDFForm import PdfWrapper, Widgets\n\nform = PdfWrapper(\"sample_template.pdf\")\n\n# change globally by iterating each text field\nfor field in form.widgets.values():\n    if isinstance(field, Widgets.Text):\n        field.alignment = 1 # center\n\n# or change at each field's widget level\nform.widgets[\"test\"].alignment = 2  # right\n\nform.fill(\n    {\n        \"test\": \"test_1\",\n        \"check\": True,\n        \"test_2\": \"test_2\",\n        \"check_2\": False,\n        \"test_3\": \"test_3\",\n        \"check_3\": True,\n    },\n)\n\nform.write(\"output.pdf\")\n</code></pre>"},{"location":"style/#change-text-field-max-length","title":"Change text field max length","text":"<p>You can change the maximum number of characters allowed in a text field:</p> <pre><code>from PyPDFForm import PdfWrapper, Widgets\n\nform = PdfWrapper(\"sample_template.pdf\")\n\n# change globally by iterating each text field\nfor field in form.widgets.values():\n    if isinstance(field, Widgets.Text):\n        field.max_length = 4\n\n# or change at each field's widget level\nform.widgets[\"test\"].max_length = 2\n\nform.fill(\n    {\n        \"test\": \"test_1\",\n        \"check\": True,\n        \"test_2\": \"test_2\",\n        \"check_2\": False,\n        \"test_3\": \"test_3\",\n        \"check_3\": True,\n    },\n)\n\nform.write(\"output.pdf\")\n</code></pre>"},{"location":"style/#enable-text-field-character-spacing-combs","title":"Enable text field character spacing (combs)","text":"<p>To enable character spacing in a text field, set its <code>.comb</code> property to <code>True</code>. This will evenly space out the characters of the text filled into the field.</p> <pre><code>from PyPDFForm import PdfWrapper, Widgets\n\nform = PdfWrapper(\"sample_template.pdf\")\n\n# change globally by iterating each text field\nfor field in form.widgets.values():\n    if isinstance(field, Widgets.Text):\n        field.max_length = 4\n        field.comb = True\n\n# or change at each field's widget level\nform.widgets[\"test\"].max_length = 2\nform.widgets[\"test\"].comb = True\n\nform.fill(\n    {\n        \"test\": \"test_1\",\n        \"check\": True,\n        \"test_2\": \"test_2\",\n        \"check_2\": False,\n        \"test_3\": \"test_3\",\n        \"check_3\": True,\n    },\n)\n\nform.write(\"output.pdf\")\n</code></pre> Warning <p>This property only takes effect when the text field also has a <code>max_length</code> set.</p>"},{"location":"style/#enable-multiline-text-field","title":"Enable multiline text field","text":"<p>To enable multiline input for a text field, set its <code>.multiline</code> property to <code>True</code>. This effectively transforms it into a paragraph field:</p> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template.pdf\")\n\nform.widgets[\"test\"].multiline = True\n\nform.fill(\n    {\n        \"test\": \"test_1\\ntest_1\",\n        \"check\": True,\n        \"test_2\": \"test_2\\ntest_2\",\n        \"check_2\": False,\n        \"test_3\": \"test_3\\ntest_3\",\n        \"check_3\": True,\n    },\n)\n\nform.write(\"output.pdf\")\n</code></pre>"},{"location":"style/#change-checkboxradio-button-size","title":"Change checkbox/radio button size","text":"<p>You can change the size of a checkbox or a group of radio buttons using a <code>float</code> value:</p> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template.pdf\")\n\nform.widgets[\"check\"].size = 50\nform.widgets[\"check_2\"].size = 40\nform.widgets[\"check_3\"].size = 60\n\nform.fill(\n    {\n        \"check\": True,\n        \"check_2\": True,\n        \"check_3\": True,\n    },\n)\n\nform.write(\"output.pdf\")\n</code></pre>"},{"location":"style/#change-dropdown-field-choices","title":"Change dropdown field choices","text":"<p>To modify the options available in a dropdown field, assign a new list of strings to the <code>.choices</code> attribute of the corresponding field. For instance, the following code snippet updates the <code>dropdown_1</code> field in this PDF form with a new set of choices:</p> Default Export ValuesCustom Export Values <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template_with_dropdown.pdf\")\n\nform.widgets[\"dropdown_1\"].choices = [\"\", \"apple\", \"banana\", \"cherry\", \"dates\"]\n\nform.write(\"output.pdf\")\n</code></pre> <p>If you want different export values from the displayed options, you can specify a list of tuples for the <code>.choices</code> attribute, where the first value of each tuple is the displayed option and the second value is the export value:</p> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template_with_dropdown.pdf\")\n\nform.widgets[\"dropdown_1\"].choices = [\n    (\"\", \"blank_export_value\"),\n    (\"apple\", \"apple_export_value\"),\n    (\"banana\", \"banana_export_value\"),\n    (\"cherry\", \"cherry_export_value\"),\n    (\"dates\", \"dates_export_value\"),\n]\n\nform.write(\"output.pdf\")\n</code></pre>"},{"location":"style/#change-dropdown-field-font","title":"Change dropdown field font","text":"<p>Before changing a dropdown field's font, you must first register the desired font.</p> <p>After registration, you can apply the registered font to any dropdown field:</p> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template_with_dropdown.pdf\")\n\nform.widgets[\"dropdown_1\"].font = \"your_registered_font\"\n\nform.write(\"output.pdf\")\n</code></pre>"},{"location":"style/#change-dropdown-field-font-size","title":"Change dropdown field font size","text":"<p>You can change a dropdown field's font size using a <code>float</code> value in PyPDFForm:</p> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template_with_dropdown.pdf\")\n\nform.widgets[\"dropdown_1\"].font_size = 30\n\nform.write(\"output.pdf\")\n</code></pre>"},{"location":"style/#change-dropdown-field-font-color","title":"Change dropdown field font color","text":"<p>You can change a dropdown field's font color using an RGB <code>tuple</code>:</p> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template_with_dropdown.pdf\")\n\nform.widgets[\"dropdown_1\"].font_color = (1, 0, 0)\n\nform.write(\"output.pdf\")\n</code></pre>"},{"location":"style/#change-field-editability","title":"Change field editability","text":"<p>The <code>readonly</code> property of each form field controls its editability. Setting <code>readonly</code> to <code>True</code> flattens the field, making it uneditable, while setting it to <code>False</code> unflattens it, making it editable. For example, the following code snippet shows how you can make different form fields editable in this PDF form after they have been flattened:</p> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template_with_dropdown.pdf\")\n\nform.fill(\n    {\n        \"test_1\": \"test_1\",\n        \"test_2\": \"test_2\",\n        \"test_3\": \"test_3\",\n        \"check_1\": True,\n        \"check_2\": True,\n        \"check_3\": True,\n        \"radio_1\": 1,\n        \"dropdown_1\": 0,\n    },\n    flatten=True,\n)\nform.widgets[\"test_2\"].readonly = False  # text\nform.widgets[\"check_3\"].readonly = False  # checkbox\nform.widgets[\"radio_1\"].readonly = False  # radio button group\nform.widgets[\"dropdown_1\"].readonly = False  # dropdown\n\nform.write(\"output.pdf\")\n</code></pre>"},{"location":"style/#change-field-visibility","title":"Change field visibility","text":"<p>The <code>hidden</code> property of each form field controls its visibility. Setting <code>hidden</code> to <code>True</code> hides the field, while setting it to <code>False</code> makes it visible:</p> <pre><code>from PyPDFForm import PdfWrapper\n\nform = PdfWrapper(\"sample_template.pdf\")\nform.widgets[\"test\"].hidden = True\n\nform.write(\"output.pdf\")\n</code></pre>"},{"location":"utils/","title":"Other utilities","text":"<p>PyPDFForm offers additional utilities similar to other PDF libraries.</p> <p>This section of the documentation uses this PDF as an example.</p>"},{"location":"utils/#blank-pdfs","title":"Blank PDFs","text":"<p>Use the <code>BlankPage</code> class with <code>PdfWrapper</code> to create new blank PDFs.</p> Single PageCustom ResolutionMultiple Pages <p>The following example generates a PDF with a single blank page:</p> <pre><code>from PyPDFForm import BlankPage, PdfWrapper\n\nblank_pdf = PdfWrapper(BlankPage())\n\nblank_pdf.write(\"output.pdf\")\n</code></pre> <p>By default, <code>BlankPage</code> generates a letter-size (612 x 792 points or 8.5 x 11 inches) blank PDF page. To change the dimensions, specify <code>width</code> and <code>height</code> (in points) when you instantiate the object:</p> <pre><code>from PyPDFForm import BlankPage, PdfWrapper\n\nblank_pdf = PdfWrapper(BlankPage(width=595.35, height=841.995)) # A4 size\n\nblank_pdf.write(\"output.pdf\")\n</code></pre> <p>To create a blank PDF with multiple pages, multiply the <code>BlankPage</code> object by the number of pages you need:</p> <pre><code>from PyPDFForm import BlankPage, PdfWrapper\n\nblank_pdf = PdfWrapper(BlankPage() * 3) # 3 pages of letter size\n\nblank_pdf.write(\"output.pdf\")\n</code></pre>"},{"location":"utils/#extract-pages","title":"Extract pages","text":"<p>The <code>PdfWrapper</code> object has a <code>.pages</code> attribute, which is a <code>PdfArray</code> of <code>PdfWrapper</code> objects representing individual pages:</p> <pre><code>from PyPDFForm import PdfWrapper\n\nfirst_page = PdfWrapper(\"sample_template.pdf\").pages[0]\nfirst_page.fill(\n    {\n        \"test\": \"test_1\",\n        \"check\": True,\n    },\n)\n\nfirst_page.write(\"output.pdf\")\n</code></pre>"},{"location":"utils/#merge-multiple-pdfs","title":"Merge multiple PDFs","text":"<p>You can merge multiple PDF files by adding their <code>PdfWrapper</code> objects. For example, to merge this PDF and this PDF:</p> Default Page OrderRearrange Page OrderBulk Merge <pre><code>from PyPDFForm import PdfWrapper\n\npdf_one = PdfWrapper(\"dummy.pdf\")\npdf_two = PdfWrapper(\"sample_template.pdf\")\nmerged = pdf_one + pdf_two\n\nmerged.write(\"output.pdf\")\n</code></pre> <pre><code>from PyPDFForm import PdfWrapper\n\npdf_one = PdfWrapper(\"dummy.pdf\")\npdf_two = PdfWrapper(\"sample_template.pdf\")\nmerged = pdf_two.pages[0] + pdf_one + pdf_two.pages[1:]\n\nmerged.write(\"output.pdf\")\n</code></pre> <p>When merging a large number of PDF files, it is more performant to use the <code>PdfArray.merge</code> method:</p> <pre><code>from PyPDFForm import PdfArray, PdfWrapper\n\npdfs = PdfArray(\n    [\n        PdfWrapper(\"dummy.pdf\"),\n        PdfWrapper(\"sample_template.pdf\"),\n        # can get very large\n    ]\n)\nmerged = pdfs.merge()\n\nmerged.write(\"output.pdf\")\n</code></pre>"},{"location":"utils/#change-pdf-version","title":"Change PDF version","text":"<p>PyPDFForm allows you to modify the PDF version up to 2.0:</p> <pre><code>from PyPDFForm import PdfWrapper\n\nnew_version = PdfWrapper(\"sample_template.pdf\").change_version(\"2.0\")\nnew_version.write(\"output.pdf\")\n</code></pre>"},{"location":"news/2024-01-01/","title":"2024-01-01: API Changes","text":"<p>Happy new year fellow developers! We start the year 2024 with a new release of v1.4.0 and  there are some important changes I'm making to the APIs of the library.</p> <ul> <li>The PDF object that gets instantiated is now <code>PyPDFForm.PdfWrapper</code>, changed from <code>PyPDFForm.PyPDFForm</code>.</li> <li>Form widgets are now accessed via the <code>PdfWrapper.widgets</code> attribute, changed from <code>PdfWrapper.elements</code>.</li> <li>The JSON schema of the form data is now accessed via a new attribute called <code>PdfWrapper.schema</code>,  changed from the old method of <code>PdfWrapper.generate_schema()</code>.</li> </ul> <p>All the old APIs will be persisted for half a year and then fully deprecated. Each of them  will emit a <code>DeprecationWarning</code> when invoked, so it is advised that you make the switch before they are  removed and start breaking your code.</p> <p>Happy hacking!</p>"},{"location":"news/2025-03-29/","title":"2025-03-29: Announcements","text":"<p>Hello fellow Python developers! With the release of v2.0.0, there are some important changes I'm making to the library:</p> <ul> <li>Since I started developing the library, versioning releases has been quite unorthodox, and there isn't any convention I followed. Starting with v2.0.0, PyPDFForm will version releases following the conventions defined by Semantic Versioning.</li> <li>PyPDFForm now renders PDF form widgets! Ever since its ancestral stage, the library has only been able to render the data you filled into a PDF form. Now if you fill a PDF form using <code>PdfWrapper</code>, the result will render the whole widget instead of just the value that got filled. If you would like to disable this behavior, please refer to the docs here.</li> </ul> <p>Happy hacking!</p>"},{"location":"news/2025-05-24/","title":"2025-05-24: V3 Announcements","text":"<p>This article provides important information about the upcoming v3.0.0 release.</p>"},{"location":"news/2025-05-24/#tl-dr","title":"TL; DR","text":"<p>PyPDFForm v3.0.0 is scheduled for release on June 24, 2025. This major release includes changes that will break compatibility with older code. To avoid issues, pin your version to &lt;=2.5.0 as soon as possible.</p> <p>Here's a list of the changes:</p> <ul> <li><code>FormWrapper</code> has been removed. Its features have been moved to <code>PdfWrapper</code>. The <code>fill</code> method of <code>PdfWrapper</code> will now work the same way it did in <code>FormWrapper</code>.</li> <li>The way to enable <code>adobe_mode</code> when filling has changed. Instead of passing <code>adobe_mode</code> as an argument to the <code>fill</code> method, you now pass it when creating a <code>PdfWrapper</code> object.</li> <li>Setting font properties for the entire document (e.g., <code>PdfWrapper(\"sample_template.pdf\", global_font_size=20)</code>) is no longer supported. You must now set font properties for each individual widget.</li> <li><code>register_font</code> is now a method of the <code>PdfWrapper</code> object, not a general class method.</li> <li><code>PdfWrapper.preview</code> is removed.</li> <li>You can no longer change the <code>button_style</code> of existing checkboxes or radio buttons. (Setting the <code>button_style</code> when you create them is still supported.)</li> <li>Render widgets flag <code>render_widgets</code> is removed.</li> </ul>"},{"location":"news/2025-05-24/#why-these-changes","title":"Why these changes?","text":"<p>When I started this project about five years ago, I didn't have as much experience as I do now. I ran into some technical problems during the initial proof of concept. One problem was that filled text fields in Adobe Acrobat sometimes only appeared when the field was selected.</p> <p>Because of this behavior in Adobe Acrobat, and because I wanted to support as many PDF viewers as possible, I decided to use a \"watermark\" approach. Instead of directly changing the form field data, this approach gathers information about each field, such as its location, font, size, and color. Then, it removes all the original form fields, creates a watermark of the PDF, draws the filled content onto the watermark, and combines the watermark with the original PDF. Even though this removes the original fields and makes the filled content look \"flattened\", it ensures that the filled PDFs only contain basic PDF data and can be viewed in any PDF application. The project has grown since then, adding features like custom form field styles and even the ability to create form fields. As of version 2.5.0, the <code>PdfWrapper</code> still uses this watermark method as its core.</p> <p>About a year ago, with the help of the community, I was finally able to solve the text field issue in Adobe Acrobat that had been present since the beginning of the project. This made it possible to directly modify the form field data when filling a PDF, which has several benefits: the form fields can remain editable after filling, there's no need for complicated calculations to determine coordinates and resolutions, and merging watermarks with the original PDF is no longer necessary, which greatly improves performance. However, the project had already developed significantly, and some features that relied on the watermark approach, such as changing font properties, couldn't be easily adapted to the new method, at least not initially. Therefore, instead of completely abandoning the watermark approach, I decided to create a new, simpler set of APIs that would support this new way of filling forms. This resulted in the <code>FormWrapper</code>.</p> <p>The <code>FormWrapper</code> turned out to be a good addition, attracting even more users because it could truly \"fill\" a PDF form as if it were done by hand. Since then, <code>PdfWrapper</code> and <code>FormWrapper</code> have existed side-by-side. However, recent developments have made it necessary to introduce even more significant and fundamental changes to the project. First, I've noticed that many users, even when using features from <code>PdfWrapper</code> like creating or renaming widgets, prefer to use <code>FormWrapper</code> for the final step of filling the PDF. In these situations, I've had to advise them to first perform the necessary actions with <code>PdfWrapper</code>, extract the stream from the <code>PdfWrapper</code> object, and then use that as input for <code>FormWrapper</code> to complete the filling process. This workflow doesn't seem very intuitive. Second, I've developed some extremely complex calculations to determine how form field data should be drawn when using the watermark method. However, I've reached a point where I can't figure out how to support landscape PDFs due to orientation issues. This makes abandoning the watermark approach even more desirable. Finally, my recent research has revealed clearer ways to implement features that were previously only achievable through the watermark method by directly manipulating form field data.</p> <p>Considering everything mentioned above, I believe it's time to introduce the next major version of PyPDFForm: v3.0.0.</p>"},{"location":"news/2025-05-24/#what-are-the-changes","title":"What are the changes?","text":"<p>In short, the goal of v3.0.0 can be summed up to:</p> <ul> <li>Merge <code>FormWrapper</code> into <code>PdfWrapper</code>.</li> <li>Reimplement most, if not all, <code>PdfWrapper</code> features, especially the <code>fill</code> method, by directly manipulating form field data.</li> <li>Preserve as much backward compatibility as possible.</li> </ul> <p>Let's talk more about backward compatibility. With changes as significant as those in this release, it's impossible to maintain complete backward compatibility. For instance, even if you use the <code>fill</code> method in the same way as before, the filled PDF forms will now be editable because the watermark method is no longer used.</p> <p>So, when I say I've tried to preserve as much backward compatibility as possible, I mean I've minimized the number of API changes. The appearance of your generated PDFs will be slightly different compared to the watermark approach, but you'll still be able to use most of PyPDFForm's APIs in the same way as before the release.</p> <p>However, some unavoidable changes will break backward compatibility. This is why this release is a major version update, as defined by Semantic Versioning. I'll do my best to explain these changes and the reasons behind them in the list below:</p> <ul> <li>As mentioned earlier, <code>FormWrapper</code> has been merged into <code>PdfWrapper</code> and completely removed. <code>FormWrapper</code> only provided basic PDF form filling features. After the merge, the <code>fill</code> method of <code>PdfWrapper</code> will function identically to how it did in <code>FormWrapper</code>.</li> <li>The <code>adobe_mode</code> parameter has been moved from the <code>fill</code> method to the <code>PdfWrapper</code> object's constructor. This change is necessary because most <code>PdfWrapper</code> features now directly manipulate form field data and need to support Adobe Acrobat. Therefore, the setting applies to the entire object rather than just the filling method.</li> <li>Previously, font properties could be set globally for each object using parameters like <code>global_font</code>, <code>global_font_size</code>, and <code>global_font_color</code> when creating the object. This is no longer possible. Font properties must now be set for each individual widget. Setting font properties globally made sense when they all needed to be applied to the same watermarks. Now that the project directly manipulates form fields, it's more logical to set them at the widget level.</li> <li><code>register_font</code> is now a method that belongs to each <code>PdfWrapper</code> object, rather than a general class method. This change should have been made earlier, and it's becoming more obvious with this release, as each registered font should only be used for a single PDF form.</li> <li>The <code>preview</code> feature has been removed. It was initially an experimental feature and has proven to create messy, unreadable previews for PDFs with many fields. There are better ways to inspect a PDF form, such as using <code>schema</code> and <code>sample_data</code>.</li> <li>Modifying the <code>button_style</code> of existing checkboxes or radio buttons by directly manipulating form field data is difficult, as it involves complex stream creation that I'm currently unable to implement. Therefore, this feature has been removed for now but may be added back in the future. Note that this change doesn't affect the ability to set the <code>button_style</code> when creating checkboxes or radio buttons.</li> <li><code>render_widgets</code> has been removed. This feature was originally added to maintain backward compatibility when the watermark approach first began supporting the rendering of widget borders and backgrounds. Since the watermark approach is no longer used, this feature is unnecessary.</li> </ul>"},{"location":"news/2025-05-24/#what-do-you-need-to-do","title":"What do you need to do?","text":"<p>First, I strongly recommend that you pin your PyPDFForm dependency version to &lt;=2.5.0 as soon as possible, unless you're certain that these changes won't cause any problems for you.</p> <p>After pinning your version, you have a couple of options:</p> <ul> <li>If any of the backward-incompatible changes affect your code, update your code accordingly, using the information provided above.</li> <li>If you prefer the old watermark approach, you can keep your version pinned to &lt;=2.5.0 indefinitely, as those older versions will remain available.</li> </ul> <p>Otherwise, once the release is made, you should have no problem upgrading to v3.0.0 and any future patches after the release.</p>"},{"location":"news/2025-05-24/#when-will-this-happen","title":"When will this happen?","text":"<p>This announcement was written and should be published on May 24, 2025. After publication, the community will have one month to review this information and make any necessary adjustments.</p> <p>Therefore, unless there's significant opposition from the community, PyPDFForm v3.0.0 will be released on June 24, 2025.</p>"},{"location":"news/2025-11-22/","title":"2025-11-22: V4 Announcements","text":"<p>Hello PyPDFForm community! A major release, v4.0.0, is planned for New Year's Day 2026. This release will officially remove APIs currently marked as deprecated and emitting warnings.</p> <p>Below is a list of these APIs and their alternatives:</p> <ul> <li><code>PdfWrapper.adobe_mode</code> will be removed; use <code>PdfWrapper.need_appearances</code>.</li> <li><code>PdfWrapper.create_widget()</code> will be removed; use <code>PdfWrapper.create_field()</code>.</li> <li>The new <code>PdfWrapper.draw()</code> API replaces older drawing APIs:<ul> <li><code>PdfWrapper.draw_text()</code> will be removed; use <code>PdfWrapper.draw()</code> with <code>PyPDFForm.RawElements.RawText</code>.</li> <li><code>PdfWrapper.draw_image()</code> will be removed; use <code>PdfWrapper.draw()</code> with <code>PyPDFForm.RawElements.RawImage</code>.</li> </ul> </li> <li><code>PyPDFForm.Text</code> will be removed; use <code>PyPDFForm.Widgets.Text</code>.</li> </ul> <p>Please go through this list and consider migrating to the new APIs, or pin your version if you wish to use the old APIs.</p> <p>Happy hacking!</p>"}]}