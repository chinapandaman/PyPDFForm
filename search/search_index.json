{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to PyPDFForm PyPDFForm is a free and open source pure-Python 3 library for PDF form processing. It contains the essential functionalities needed to interact with PDF forms: Inspect what data a PDF form needs to be filled with. Fill a PDF form by simply creating a Python dictionary. Create form fields on a PDF. It also supports other common utilities such as extracting pages and merging multiple PDFs together. User Guide Installation and setup PDF coordinate system Register fonts Create form fields Inspect form field data Fill PDF forms Change form field styles Draw elements Other utilities Developer Guide Developer Intro Pull Request Requirements Hosting Docs Locally Testing Releasing News 2025-05-24: V3 Announcements 2025-03-29: Announcements 2024-01-01: API Changes","title":"Welcome to PyPDFForm"},{"location":"#welcome-to-pypdfform","text":"PyPDFForm is a free and open source pure-Python 3 library for PDF form processing. It contains the essential functionalities needed to interact with PDF forms: Inspect what data a PDF form needs to be filled with. Fill a PDF form by simply creating a Python dictionary. Create form fields on a PDF. It also supports other common utilities such as extracting pages and merging multiple PDFs together.","title":"Welcome to PyPDFForm"},{"location":"#user-guide","text":"Installation and setup PDF coordinate system Register fonts Create form fields Inspect form field data Fill PDF forms Change form field styles Draw elements Other utilities","title":"User Guide"},{"location":"#developer-guide","text":"Developer Intro Pull Request Requirements Hosting Docs Locally Testing Releasing","title":"Developer Guide"},{"location":"#news","text":"2025-05-24: V3 Announcements 2025-03-29: Announcements 2024-01-01: API Changes","title":"News"},{"location":"coordinate/","text":"PDF coordinate system The PDF coordinate system originates at the bottom left of the page. The unit of measurement is \"points,\" with 72 points per inch. PyPDFForm uses this coordinate system in its APIs to create fields, text, and images on a PDF. Generate a coordinate grid view To enhance the user experience with the coordinate system, PyPDFForm provides a grid view that helps determine the optimal placement of elements on a PDF. To generate a coordinate grid view for this PDF , use the following code: from PyPDFForm import PdfWrapper grid_view_pdf = PdfWrapper(\"sample_template.pdf\").generate_coordinate_grid( color=(1, 0, 0), # optional margin=100 # optional ) grid_view_pdf.write(\"output.pdf\") The generate_coordinate_grid method accepts two optional parameters: color and margin . The color parameter sets the grid view color (defaulting to red), and the margin parameter adjusts the coordinate grid view's margin in points (defaulting to 100 points).","title":"PDF coordinate system"},{"location":"coordinate/#pdf-coordinate-system","text":"The PDF coordinate system originates at the bottom left of the page. The unit of measurement is \"points,\" with 72 points per inch. PyPDFForm uses this coordinate system in its APIs to create fields, text, and images on a PDF.","title":"PDF coordinate system"},{"location":"coordinate/#generate-a-coordinate-grid-view","text":"To enhance the user experience with the coordinate system, PyPDFForm provides a grid view that helps determine the optimal placement of elements on a PDF. To generate a coordinate grid view for this PDF , use the following code: from PyPDFForm import PdfWrapper grid_view_pdf = PdfWrapper(\"sample_template.pdf\").generate_coordinate_grid( color=(1, 0, 0), # optional margin=100 # optional ) grid_view_pdf.write(\"output.pdf\") The generate_coordinate_grid method accepts two optional parameters: color and margin . The color parameter sets the grid view color (defaulting to red), and the margin parameter adjusts the coordinate grid view's margin in points (defaulting to 100 points).","title":"Generate a coordinate grid view"},{"location":"dev_changes/","text":"Pull Request Requirements When submitting a pull request, follow these guidelines for a smooth review process. Code changes PyPDFForm welcomes contributions from developers of all levels and doesn't enforce strict coding rules. Your PR should follow these conventions: Prefer small, incremental changes. For large changes, request a feature branch in your issue and open your PR against that branch, as they will likely need revision before merging into master. Ensure your changes pass all linters. PyPDFForm uses rules from pylint , ruff , and pyright . Run linting inside the development container to check. Your changes must pass all tests and have 100% coverage. You can read more about testing here . If you are changing the user APIs or any other parts of the code that are relevant, please update the appropriate documentation too. Merge process Your PR will be reviewed before merging into the master branch. If your changes are too extensive for inline comments, you may need to reopen your PR against a new feature branch for revision. Additionally, your PR must pass these CI checks: Linting on the source code. Tests will be run on three mainstream operating systems: ubuntu , windows , and macos , and across all Python versions the library supports on each OS. Once the CI is green and your code looks good, the PR will be merged into the master branch. They will be deployed on the next release.","title":"Pull Request Requirements"},{"location":"dev_changes/#pull-request-requirements","text":"When submitting a pull request, follow these guidelines for a smooth review process.","title":"Pull Request Requirements"},{"location":"dev_changes/#code-changes","text":"PyPDFForm welcomes contributions from developers of all levels and doesn't enforce strict coding rules. Your PR should follow these conventions: Prefer small, incremental changes. For large changes, request a feature branch in your issue and open your PR against that branch, as they will likely need revision before merging into master. Ensure your changes pass all linters. PyPDFForm uses rules from pylint , ruff , and pyright . Run linting inside the development container to check. Your changes must pass all tests and have 100% coverage. You can read more about testing here . If you are changing the user APIs or any other parts of the code that are relevant, please update the appropriate documentation too.","title":"Code changes"},{"location":"dev_changes/#merge-process","text":"Your PR will be reviewed before merging into the master branch. If your changes are too extensive for inline comments, you may need to reopen your PR against a new feature branch for revision. Additionally, your PR must pass these CI checks: Linting on the source code. Tests will be run on three mainstream operating systems: ubuntu , windows , and macos , and across all Python versions the library supports on each OS. Once the CI is green and your code looks good, the PR will be merged into the master branch. They will be deployed on the next release.","title":"Merge process"},{"location":"dev_doc/","text":"Hosting Docs Locally Update the relevant documentation when changing user APIs or other significant code sections. PyPDFForm uses MkDocs to build its documentation. To host the documentation locally, run: mkdocs serve The documentation will be available at http://127.0.0.1:8000/ . Alternatively, to run the documentation in the development container: docs The documentation will be available at http://localhost:8000/ .","title":"Hosting Docs Locally"},{"location":"dev_doc/#hosting-docs-locally","text":"Update the relevant documentation when changing user APIs or other significant code sections. PyPDFForm uses MkDocs to build its documentation. To host the documentation locally, run: mkdocs serve The documentation will be available at http://127.0.0.1:8000/ . Alternatively, to run the documentation in the development container: docs The documentation will be available at http://localhost:8000/ .","title":"Hosting Docs Locally"},{"location":"dev_intro/","text":"Developer Intro PyPDFForm is designed for Python developers. This documentation section is intended for contributors to PyPDFForm, not its end-users. Setup To get started, create a virtual environment and install the development dependencies using your preferred package manager. The command below uses uv : uv pip install -U -r pyproject.toml --extra dev PyPDFForm also offers a development container. To build it, run the following command in the project's root directory: docker build -t pypdfform-dev . Once successfully built, you can open a shell inside the container by running: docker run -it --rm -p 8000:8000 -v ${PWD}:/pypdfform pypdfform-dev Running tests See testing PyPDFForm with pytest . Creating issues When creating a GitHub issue, follow these guidelines: The issue title should have the format PPF-<issue number>: <title of the issue> . The issue description should be as descriptive as possible, preferably with the following: A code snippet related to the issue. A PDF form template used by the code snippet. Screenshots that can help visualize the issue. Opening pull requests Before opening a pull request, create an issue. When opening the pull request, follow these guidelines: The PR title should be the same as its respective issue, so PPF-<issue number>: <title of the issue> . The PR description should contain a brief explanation of the changes. Once opened, the PR should be linked to its respective issue.","title":"Developer Intro"},{"location":"dev_intro/#developer-intro","text":"PyPDFForm is designed for Python developers. This documentation section is intended for contributors to PyPDFForm, not its end-users.","title":"Developer Intro"},{"location":"dev_intro/#setup","text":"To get started, create a virtual environment and install the development dependencies using your preferred package manager. The command below uses uv : uv pip install -U -r pyproject.toml --extra dev PyPDFForm also offers a development container. To build it, run the following command in the project's root directory: docker build -t pypdfform-dev . Once successfully built, you can open a shell inside the container by running: docker run -it --rm -p 8000:8000 -v ${PWD}:/pypdfform pypdfform-dev","title":"Setup"},{"location":"dev_intro/#running-tests","text":"See testing PyPDFForm with pytest .","title":"Running tests"},{"location":"dev_intro/#creating-issues","text":"When creating a GitHub issue, follow these guidelines: The issue title should have the format PPF-<issue number>: <title of the issue> . The issue description should be as descriptive as possible, preferably with the following: A code snippet related to the issue. A PDF form template used by the code snippet. Screenshots that can help visualize the issue.","title":"Creating issues"},{"location":"dev_intro/#opening-pull-requests","text":"Before opening a pull request, create an issue. When opening the pull request, follow these guidelines: The PR title should be the same as its respective issue, so PPF-<issue number>: <title of the issue> . The PR description should contain a brief explanation of the changes. Once opened, the PR should be linked to its respective issue.","title":"Opening pull requests"},{"location":"dev_release/","text":"Releasing The PyPDFForm release process involves these initial steps: A version bump commit that runs black and isort on the codebase. A new GitHub release with auto-generated changelogs. These steps trigger the deployment CI. Versioning PyPDFForm follows the conventions defined by Semantic Versioning . Deploy process A GitHub release triggers two CIs: Deploy , which will create the distribution and upload it to PyPI . Deploy Docs , which will tear down and rebuild the GitHub page where the doc site is hosted. When are releases done? Release timing depends on changes pending deployment on the master branch. Generally: Serious bugs are usually released immediately after they are fixed. New features can usually wait and are released on a weekly basis. Trivial changes are usually bundled with other changes and can wait indefinitely.","title":"Releasing"},{"location":"dev_release/#releasing","text":"The PyPDFForm release process involves these initial steps: A version bump commit that runs black and isort on the codebase. A new GitHub release with auto-generated changelogs. These steps trigger the deployment CI.","title":"Releasing"},{"location":"dev_release/#versioning","text":"PyPDFForm follows the conventions defined by Semantic Versioning .","title":"Versioning"},{"location":"dev_release/#deploy-process","text":"A GitHub release triggers two CIs: Deploy , which will create the distribution and upload it to PyPI . Deploy Docs , which will tear down and rebuild the GitHub page where the doc site is hosted.","title":"Deploy process"},{"location":"dev_release/#when-are-releases-done","text":"Release timing depends on changes pending deployment on the master branch. Generally: Serious bugs are usually released immediately after they are fixed. New features can usually wait and are released on a weekly basis. Trivial changes are usually bundled with other changes and can wait indefinitely.","title":"When are releases done?"},{"location":"dev_test/","text":"Testing PyPDFForm uses pytest for testing and coverage.py for measuring test coverage. To run the tests, execute: coverage run -m pytest && coverage report --fail-under=100 Alternatively, in the development container, run: test Generate coverage report To generate a test coverage report, run: coverage run -m pytest && coverage html View the coverage report by opening htmlcov/index.html in a browser. Alternatively, in the development container, run: coverage And the coverage report can be found at http://localhost:8000/htmlcov/index.html . Test breakdown Although each PyPDFForm test is unique, most follow a general paradigm. Most tests can be summarized into three steps: Define an expected PDF file that the outcome of the test should look like. Execute a sequence of code using PyPDFForm to generate a PDF that should look like the expected PDF file. Compare the PDF generated by the test with the expected PDF file. Consider this example test: def test_fill(pdf_samples, request): expected_path = os.path.join(pdf_samples, \"sample_filled.pdf\") with open(expected_path, \"rb+\") as f: obj = PdfWrapper( os.path.join(pdf_samples, \"sample_template.pdf\") ).fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) request.config.results[\"expected_path\"] = expected_path request.config.results[\"stream\"] = obj.read() expected = f.read() assert len(obj.read()) == len(expected) assert obj.read() == expected The test starts by defining an expected PDF sample_filled.pdf : expected_path = os.path.join(pdf_samples, \"sample_filled.pdf\") The test then fills sample_template.pdf with a data dictionary using PdfWrapper : obj = PdfWrapper( os.path.join(pdf_samples, \"sample_template.pdf\") ).fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) Include these two lines in most tests to simplify updating old tests: request.config.results[\"expected_path\"] = expected_path request.config.results[\"stream\"] = obj.read() Finally, the test compares the resulted stream from the test with the expected file stream: expected = f.read() assert len(obj.read()) == len(expected) assert obj.read() == expected","title":"Testing"},{"location":"dev_test/#testing","text":"PyPDFForm uses pytest for testing and coverage.py for measuring test coverage. To run the tests, execute: coverage run -m pytest && coverage report --fail-under=100 Alternatively, in the development container, run: test","title":"Testing"},{"location":"dev_test/#generate-coverage-report","text":"To generate a test coverage report, run: coverage run -m pytest && coverage html View the coverage report by opening htmlcov/index.html in a browser. Alternatively, in the development container, run: coverage And the coverage report can be found at http://localhost:8000/htmlcov/index.html .","title":"Generate coverage report"},{"location":"dev_test/#test-breakdown","text":"Although each PyPDFForm test is unique, most follow a general paradigm. Most tests can be summarized into three steps: Define an expected PDF file that the outcome of the test should look like. Execute a sequence of code using PyPDFForm to generate a PDF that should look like the expected PDF file. Compare the PDF generated by the test with the expected PDF file. Consider this example test: def test_fill(pdf_samples, request): expected_path = os.path.join(pdf_samples, \"sample_filled.pdf\") with open(expected_path, \"rb+\") as f: obj = PdfWrapper( os.path.join(pdf_samples, \"sample_template.pdf\") ).fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) request.config.results[\"expected_path\"] = expected_path request.config.results[\"stream\"] = obj.read() expected = f.read() assert len(obj.read()) == len(expected) assert obj.read() == expected The test starts by defining an expected PDF sample_filled.pdf : expected_path = os.path.join(pdf_samples, \"sample_filled.pdf\") The test then fills sample_template.pdf with a data dictionary using PdfWrapper : obj = PdfWrapper( os.path.join(pdf_samples, \"sample_template.pdf\") ).fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) Include these two lines in most tests to simplify updating old tests: request.config.results[\"expected_path\"] = expected_path request.config.results[\"stream\"] = obj.read() Finally, the test compares the resulted stream from the test with the expected file stream: expected = f.read() assert len(obj.read()) == len(expected) assert obj.read() == expected","title":"Test breakdown"},{"location":"draw/","text":"Draw elements PyPDFForm enables you to draw elements on a PDF, which is useful when a field is missing from your PDF form or when you need to add text or images. This section of the documentation uses this PDF as an example. Understanding the PDF coordinate system is necessary for this section. All optional parameters will have a comment # optional after each of them. Draw text To use a custom font, see how to register it here . from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\").draw_text( text=\"random text\", page_number=1, x=300, y=225, font=\"your_registered_font\", # optional font_size=12, # optional font_color=(1, 0, 0) # optional ) pdf.write(\"output.pdf\") Draw image For the rotation parameter, a positive value rotates the image counter-clockwise, and a negative value rotates it clockwise. from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\").draw_image( image=\"sample_image.jpg\", page_number=1, x=100, y=100, width=400, height=225, rotation=0 # optional ) pdf.write(\"output.pdf\")","title":"Draw elements"},{"location":"draw/#draw-elements","text":"PyPDFForm enables you to draw elements on a PDF, which is useful when a field is missing from your PDF form or when you need to add text or images. This section of the documentation uses this PDF as an example. Understanding the PDF coordinate system is necessary for this section. All optional parameters will have a comment # optional after each of them.","title":"Draw elements"},{"location":"draw/#draw-text","text":"To use a custom font, see how to register it here . from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\").draw_text( text=\"random text\", page_number=1, x=300, y=225, font=\"your_registered_font\", # optional font_size=12, # optional font_color=(1, 0, 0) # optional ) pdf.write(\"output.pdf\")","title":"Draw text"},{"location":"draw/#draw-image","text":"For the rotation parameter, a positive value rotates the image counter-clockwise, and a negative value rotates it clockwise. from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\").draw_image( image=\"sample_image.jpg\", page_number=1, x=100, y=100, width=400, height=225, rotation=0 # optional ) pdf.write(\"output.pdf\")","title":"Draw image"},{"location":"fill/","text":"Fill PDF forms PyPDFForm fills a PDF form using a flat, non-nested dictionary. The filled form is editable by default. When you call the fill method, you can set the optional parameter flatten to True to flatten the filled form, making it uneditable. Fill text field and checkbox When filling this PDF , note that text fields are filled with string values and checkboxes with boolean values: from PyPDFForm import PdfWrapper filled = PdfWrapper( \"sample_template.pdf\", adobe_mode=False # optional, set to True for Adobe Acrobat compatibility ).fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, flatten=False # optional, set to True to flatten the filled PDF form ) filled.write(\"output.pdf\") Fill radio button group A radio button group is a collection of radio buttons sharing the same name on a PDF form. A PDF form with radio button groups can be filled using integer values, where the value indicates which radio button to select within each group: from PyPDFForm import PdfWrapper filled = PdfWrapper( \"sample_template_with_radio_button.pdf\", adobe_mode=False # optional, set to True for Adobe Acrobat compatibility ).fill( { \"radio_1\": 0, \"radio_2\": 1, \"radio_3\": 2, }, flatten=False # optional, set to True to flatten the filled PDF form ) filled.write(\"output.pdf\") Fill dropdown field As with radio buttons, select a dropdown choice by specifying its integer value. For example, to fill this PDF : from PyPDFForm import PdfWrapper filled = PdfWrapper( \"sample_template_with_dropdown.pdf\", adobe_mode=False # optional, set to True for Adobe Acrobat compatibility ).fill( { \"dropdown_1\": 1 }, flatten=False # optional, set to True to flatten the filled PDF form ) filled.write(\"output.pdf\") You can also specify a dropdown option by its string value: from PyPDFForm import PdfWrapper filled = PdfWrapper( \"sample_template_with_dropdown.pdf\", adobe_mode=False # optional, set to True for Adobe Acrobat compatibility ).fill( { \"dropdown_1\": \"bar\" }, flatten=False # optional, set to True to flatten the filled PDF form ) filled.write(\"output.pdf\") NOTE: If you fill a dropdown field with a string value that is not one of its existing options, the new value is added as the last option in the dropdown and automatically selected. Fill signature field A signature field enables signing a PDF form with a handwritten signature image. To fill a signature field, consider this PDF and this signature image : from PyPDFForm import PdfWrapper signed = PdfWrapper( \"sample_template_with_signature.pdf\", adobe_mode=False # optional, set to True for Adobe Acrobat compatibility ).fill( { \"signature\": \"sample_signature.png\" }, flatten=False # optional, set to True to flatten the filled PDF form ) signed.write(\"output.pdf\") NOTE: The signature value in your dictionary can be a file path, an open file object, or a bytes file stream, as described here . By default, the library preserves the aspect ratio of the signature image when filling it. You can disable this by setting the preserve_aspect_ratio property to False on the signature field: from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template_with_signature.pdf\") pdf.widgets[\"signature\"].preserve_aspect_ratio = False pdf.fill( { \"signature\": \"sample_signature.png\" }, ) pdf.write(\"output.pdf\") Fill image field Fill an image field similarly to a signature field, using a file path, file object, or file stream. To fill an image field, consider this PDF and this image : from PyPDFForm import PdfWrapper filled = PdfWrapper( \"sample_template_with_image_field.pdf\", adobe_mode=False # optional, set to True for Adobe Acrobat compatibility ).fill( { \"image_1\": \"sample_image.jpg\" }, flatten=False # optional, set to True to flatten the filled PDF form ) filled.write(\"output.pdf\") Unlike the signature field, the library does not preserve the aspect ratio of a regular image by default. You can enable this by setting the preserve_aspect_ratio property to True on the image field: from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template_with_image_field.pdf\") pdf.widgets[\"image_1\"].preserve_aspect_ratio = True pdf.fill( { \"image_1\": \"sample_image.jpg\" }, ) pdf.write(\"output.pdf\")","title":"Fill PDF forms"},{"location":"fill/#fill-pdf-forms","text":"PyPDFForm fills a PDF form using a flat, non-nested dictionary. The filled form is editable by default. When you call the fill method, you can set the optional parameter flatten to True to flatten the filled form, making it uneditable.","title":"Fill PDF forms"},{"location":"fill/#fill-text-field-and-checkbox","text":"When filling this PDF , note that text fields are filled with string values and checkboxes with boolean values: from PyPDFForm import PdfWrapper filled = PdfWrapper( \"sample_template.pdf\", adobe_mode=False # optional, set to True for Adobe Acrobat compatibility ).fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, flatten=False # optional, set to True to flatten the filled PDF form ) filled.write(\"output.pdf\")","title":"Fill text field and checkbox"},{"location":"fill/#fill-radio-button-group","text":"A radio button group is a collection of radio buttons sharing the same name on a PDF form. A PDF form with radio button groups can be filled using integer values, where the value indicates which radio button to select within each group: from PyPDFForm import PdfWrapper filled = PdfWrapper( \"sample_template_with_radio_button.pdf\", adobe_mode=False # optional, set to True for Adobe Acrobat compatibility ).fill( { \"radio_1\": 0, \"radio_2\": 1, \"radio_3\": 2, }, flatten=False # optional, set to True to flatten the filled PDF form ) filled.write(\"output.pdf\")","title":"Fill radio button group"},{"location":"fill/#fill-dropdown-field","text":"As with radio buttons, select a dropdown choice by specifying its integer value. For example, to fill this PDF : from PyPDFForm import PdfWrapper filled = PdfWrapper( \"sample_template_with_dropdown.pdf\", adobe_mode=False # optional, set to True for Adobe Acrobat compatibility ).fill( { \"dropdown_1\": 1 }, flatten=False # optional, set to True to flatten the filled PDF form ) filled.write(\"output.pdf\") You can also specify a dropdown option by its string value: from PyPDFForm import PdfWrapper filled = PdfWrapper( \"sample_template_with_dropdown.pdf\", adobe_mode=False # optional, set to True for Adobe Acrobat compatibility ).fill( { \"dropdown_1\": \"bar\" }, flatten=False # optional, set to True to flatten the filled PDF form ) filled.write(\"output.pdf\") NOTE: If you fill a dropdown field with a string value that is not one of its existing options, the new value is added as the last option in the dropdown and automatically selected.","title":"Fill dropdown field"},{"location":"fill/#fill-signature-field","text":"A signature field enables signing a PDF form with a handwritten signature image. To fill a signature field, consider this PDF and this signature image : from PyPDFForm import PdfWrapper signed = PdfWrapper( \"sample_template_with_signature.pdf\", adobe_mode=False # optional, set to True for Adobe Acrobat compatibility ).fill( { \"signature\": \"sample_signature.png\" }, flatten=False # optional, set to True to flatten the filled PDF form ) signed.write(\"output.pdf\") NOTE: The signature value in your dictionary can be a file path, an open file object, or a bytes file stream, as described here . By default, the library preserves the aspect ratio of the signature image when filling it. You can disable this by setting the preserve_aspect_ratio property to False on the signature field: from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template_with_signature.pdf\") pdf.widgets[\"signature\"].preserve_aspect_ratio = False pdf.fill( { \"signature\": \"sample_signature.png\" }, ) pdf.write(\"output.pdf\")","title":"Fill signature field"},{"location":"fill/#fill-image-field","text":"Fill an image field similarly to a signature field, using a file path, file object, or file stream. To fill an image field, consider this PDF and this image : from PyPDFForm import PdfWrapper filled = PdfWrapper( \"sample_template_with_image_field.pdf\", adobe_mode=False # optional, set to True for Adobe Acrobat compatibility ).fill( { \"image_1\": \"sample_image.jpg\" }, flatten=False # optional, set to True to flatten the filled PDF form ) filled.write(\"output.pdf\") Unlike the signature field, the library does not preserve the aspect ratio of a regular image by default. You can enable this by setting the preserve_aspect_ratio property to True on the image field: from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template_with_image_field.pdf\") pdf.widgets[\"image_1\"].preserve_aspect_ratio = True pdf.fill( { \"image_1\": \"sample_image.jpg\" }, ) pdf.write(\"output.pdf\")","title":"Fill image field"},{"location":"font/","text":"Register fonts PyPDFForm enables the use of custom fonts in certain APIs. To use a custom font, you must first register its TrueType (.ttf) file. For example, to use a font from the Liberation Serif family, register its TrueType file (e.g., LiberationSerif-BoldItalic.ttf ) as follows: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template.pdf\") form.register_font(\"new_font_name\", \"LiberationSerif-BoldItalic.ttf\") In this example, LiberationSerif-BoldItalic.ttf is registered as new_font_name . You can now reference this font in the object's APIs using the name new_font_name . Get registered fonts To see which fonts have been registered, access the fonts attribute of the PdfWrapper object: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template.pdf\") form.register_font(\"new_font_name\", \"LiberationSerif-BoldItalic.ttf\") print(form.fonts) The fonts attribute lists the names of the registered fonts.","title":"Register fonts"},{"location":"font/#register-fonts","text":"PyPDFForm enables the use of custom fonts in certain APIs. To use a custom font, you must first register its TrueType (.ttf) file. For example, to use a font from the Liberation Serif family, register its TrueType file (e.g., LiberationSerif-BoldItalic.ttf ) as follows: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template.pdf\") form.register_font(\"new_font_name\", \"LiberationSerif-BoldItalic.ttf\") In this example, LiberationSerif-BoldItalic.ttf is registered as new_font_name . You can now reference this font in the object's APIs using the name new_font_name .","title":"Register fonts"},{"location":"font/#get-registered-fonts","text":"To see which fonts have been registered, access the fonts attribute of the PdfWrapper object: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template.pdf\") form.register_font(\"new_font_name\", \"LiberationSerif-BoldItalic.ttf\") print(form.fonts) The fonts attribute lists the names of the registered fonts.","title":"Get registered fonts"},{"location":"inspect/","text":"Inspect form field data After preparing a PDF form, use PyPDFForm to inspect its field names and determine the data required for filling it. You can choose from multiple inspection methods to suit your needs. This section of the documentation uses this PDF as an example. Generate a JSON schema that describes a PDF form You can describe the dictionary used to fill a PDF form using a JSON schema. For example: import json from PyPDFForm import PdfWrapper pdf_form_schema = PdfWrapper(\"sample_template.pdf\").schema print(json.dumps(pdf_form_schema, indent=4, sort_keys=True)) The above snippet will yield the following output: { \"properties\": { \"check\": { \"type\": \"boolean\" }, \"check_2\": { \"type\": \"boolean\" }, \"check_3\": { \"type\": \"boolean\" }, \"test\": { \"type\": \"string\" }, \"test_2\": { \"type\": \"string\" }, \"test_3\": { \"type\": \"string\" } }, \"type\": \"object\" } In this example, sample_template.pdf contains three text fields ( test , test_2 , and test_3 ) of type string and three checkboxes ( check , check_2 , and check_3 ) of type boolean . You can use the PyPDFForm-generated JSON schema to validate the data used for filling a PDF form. Inspect PDF form data To inspect the current filled data of a PDF form, use the .data attribute. For example, the following snippet inspects the current filled data for this PDF : from pprint import pprint from PyPDFForm import PdfWrapper pprint(PdfWrapper(\"sample_template.pdf\").data) The above snippet will give you this dictionary: {'check': True, 'check_2': True, 'check_3': True, 'test': 'test', 'test_2': 'test2', 'test_3': 'test3'} Generate sample data PyPDFForm can also generate sample data for filling a PDF form: from pprint import pprint from PyPDFForm import PdfWrapper pprint(PdfWrapper(\"sample_template.pdf\").sample_data) The above snippet will give you a sample dictionary: {'check': True, 'check_2': True, 'check_3': True, 'test': 'test', 'test_2': 'test_2', 'test_3': 'test_3'}","title":"Inspect form field data"},{"location":"inspect/#inspect-form-field-data","text":"After preparing a PDF form, use PyPDFForm to inspect its field names and determine the data required for filling it. You can choose from multiple inspection methods to suit your needs. This section of the documentation uses this PDF as an example.","title":"Inspect form field data"},{"location":"inspect/#generate-a-json-schema-that-describes-a-pdf-form","text":"You can describe the dictionary used to fill a PDF form using a JSON schema. For example: import json from PyPDFForm import PdfWrapper pdf_form_schema = PdfWrapper(\"sample_template.pdf\").schema print(json.dumps(pdf_form_schema, indent=4, sort_keys=True)) The above snippet will yield the following output: { \"properties\": { \"check\": { \"type\": \"boolean\" }, \"check_2\": { \"type\": \"boolean\" }, \"check_3\": { \"type\": \"boolean\" }, \"test\": { \"type\": \"string\" }, \"test_2\": { \"type\": \"string\" }, \"test_3\": { \"type\": \"string\" } }, \"type\": \"object\" } In this example, sample_template.pdf contains three text fields ( test , test_2 , and test_3 ) of type string and three checkboxes ( check , check_2 , and check_3 ) of type boolean . You can use the PyPDFForm-generated JSON schema to validate the data used for filling a PDF form.","title":"Generate a JSON schema that describes a PDF form"},{"location":"inspect/#inspect-pdf-form-data","text":"To inspect the current filled data of a PDF form, use the .data attribute. For example, the following snippet inspects the current filled data for this PDF : from pprint import pprint from PyPDFForm import PdfWrapper pprint(PdfWrapper(\"sample_template.pdf\").data) The above snippet will give you this dictionary: {'check': True, 'check_2': True, 'check_3': True, 'test': 'test', 'test_2': 'test2', 'test_3': 'test3'}","title":"Inspect PDF form data"},{"location":"inspect/#generate-sample-data","text":"PyPDFForm can also generate sample data for filling a PDF form: from pprint import pprint from PyPDFForm import PdfWrapper pprint(PdfWrapper(\"sample_template.pdf\").sample_data) The above snippet will give you a sample dictionary: {'check': True, 'check_2': True, 'check_3': True, 'test': 'test', 'test_2': 'test_2', 'test_3': 'test_3'}","title":"Generate sample data"},{"location":"install/","text":"Installation and setup PyPDFForm is available on PyPI and can be installed using pip, which is the most common and recommended tool. Prerequisites PyPDFForm officially supports Python 3.10 and newer versions that are currently in their active life cycles. This typically includes the minimum supported version and the four major versions above it. For details on Python version life cycles, refer to this page . NOTE: While official support is limited to active Python versions, PyPDFForm generally avoids features specific to particular major Python versions. It is expected to be functional with Python 3.7+ (due to its use of Postponed Evaluation of Annotations for type hints, introduced in Python 3.7), though these versions are not actively tested. Install using pip It is highly recommended to create a virtual environment before installation. Then, run the following command to install PyPDFForm: pip install PyPDFForm To upgrade PyPDFForm and all its dependencies, run: pip install -U PyPDFForm Create a PDF wrapper The main user interface of the library is the PdfWrapper class. It implements most PyPDFForm APIs and accepts various optional parameters, the most important of which is the PDF form template. For example, to use this PDF as a template, instantiate the PdfWrapper object as follows: from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\") PyPDFForm provides an adapter for different file interaction methods in Python, which allows you to pass your PDF form to PdfWrapper as a file path, an open file object, or a bytes file stream. This means the following two snippets are equivalent to the above: from PyPDFForm import PdfWrapper with open(\"sample_template.pdf\", \"rb+\") as template: pdf = PdfWrapper(template) from PyPDFForm import PdfWrapper with open(\"sample_template.pdf\", \"rb+\") as template: pdf = PdfWrapper(template.read()) This file adaptation applies to all PyPDFForm APIs. You can replace file path parameters with file objects or streams throughout the documentation. Create an Adobe Acrobat compatible PDF wrapper Adobe Acrobat has known issues displaying PDF forms with filled text fields. Specifically, the text content may only be visible when the text field is selected. This issue is not present in browsers like Chrome or PDF viewers such as Document Viewer (the default PDF application on Ubuntu). By setting the optional parameter adobe_mode (default value is False ) to True when instantiating the PdfWrapper object, you ensure that the PDF can be processed and displayed correctly by Adobe Acrobat: from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\", adobe_mode=True) NOTE: PDF objects with adobe_mode enabled are optimized for viewing in Adobe Acrobat. Other PDF viewers might experience rendering issues with certain field styles, such as text font or field borders. Therefore, only enable adobe_mode when the generated PDFs are intended to be viewed with Adobe Acrobat. Use full name for PDF form fields According to section 12.7.3.2 of the PDF standard (page 434), PDF form fields can have fully qualified names constructed using the pattern <parent_field_name>.<field_name> . PyPDFForm allows you to access fields by their full names by setting use_full_widget_name to True when instantiating PdfWrapper . For example, to use this PDF : from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template_with_full_key.pdf\", use_full_widget_name=True) This enables accessing fields by their full names. For instance, you can access the checkbox labeled Gain de 2 classes using its full name Gain de 2 classes.0 instead of its partial name 0 . NOTE: When using full names, the update_widget_key and commit_widget_key_updates methods of PdfWrapper are disabled and raise a NotImplementedError because full names involve both the field and its parent. Write to a file PdfWrapper behaves like an open file object, allowing you to write the PDF to another file object. For example, to write to a disk file: from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\") with open(\"output.pdf\", \"wb+\") as output: output.write(pdf.read()) It doesn't have to be a disk file; it can be a memory buffer as well: from io import BytesIO from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\") with BytesIO() as output: output.write(pdf.read()) In addition to behaving like a file object, PdfWrapper also implements a write method that allows you to write the PDF to a disk file by specifying the path: from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\") pdf.write(\"output.pdf\")","title":"Installation and setup"},{"location":"install/#installation-and-setup","text":"PyPDFForm is available on PyPI and can be installed using pip, which is the most common and recommended tool.","title":"Installation and setup"},{"location":"install/#prerequisites","text":"PyPDFForm officially supports Python 3.10 and newer versions that are currently in their active life cycles. This typically includes the minimum supported version and the four major versions above it. For details on Python version life cycles, refer to this page . NOTE: While official support is limited to active Python versions, PyPDFForm generally avoids features specific to particular major Python versions. It is expected to be functional with Python 3.7+ (due to its use of Postponed Evaluation of Annotations for type hints, introduced in Python 3.7), though these versions are not actively tested.","title":"Prerequisites"},{"location":"install/#install-using-pip","text":"It is highly recommended to create a virtual environment before installation. Then, run the following command to install PyPDFForm: pip install PyPDFForm To upgrade PyPDFForm and all its dependencies, run: pip install -U PyPDFForm","title":"Install using pip"},{"location":"install/#create-a-pdf-wrapper","text":"The main user interface of the library is the PdfWrapper class. It implements most PyPDFForm APIs and accepts various optional parameters, the most important of which is the PDF form template. For example, to use this PDF as a template, instantiate the PdfWrapper object as follows: from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\") PyPDFForm provides an adapter for different file interaction methods in Python, which allows you to pass your PDF form to PdfWrapper as a file path, an open file object, or a bytes file stream. This means the following two snippets are equivalent to the above: from PyPDFForm import PdfWrapper with open(\"sample_template.pdf\", \"rb+\") as template: pdf = PdfWrapper(template) from PyPDFForm import PdfWrapper with open(\"sample_template.pdf\", \"rb+\") as template: pdf = PdfWrapper(template.read()) This file adaptation applies to all PyPDFForm APIs. You can replace file path parameters with file objects or streams throughout the documentation.","title":"Create a PDF wrapper"},{"location":"install/#create-an-adobe-acrobat-compatible-pdf-wrapper","text":"Adobe Acrobat has known issues displaying PDF forms with filled text fields. Specifically, the text content may only be visible when the text field is selected. This issue is not present in browsers like Chrome or PDF viewers such as Document Viewer (the default PDF application on Ubuntu). By setting the optional parameter adobe_mode (default value is False ) to True when instantiating the PdfWrapper object, you ensure that the PDF can be processed and displayed correctly by Adobe Acrobat: from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\", adobe_mode=True) NOTE: PDF objects with adobe_mode enabled are optimized for viewing in Adobe Acrobat. Other PDF viewers might experience rendering issues with certain field styles, such as text font or field borders. Therefore, only enable adobe_mode when the generated PDFs are intended to be viewed with Adobe Acrobat.","title":"Create an Adobe Acrobat compatible PDF wrapper"},{"location":"install/#use-full-name-for-pdf-form-fields","text":"According to section 12.7.3.2 of the PDF standard (page 434), PDF form fields can have fully qualified names constructed using the pattern <parent_field_name>.<field_name> . PyPDFForm allows you to access fields by their full names by setting use_full_widget_name to True when instantiating PdfWrapper . For example, to use this PDF : from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template_with_full_key.pdf\", use_full_widget_name=True) This enables accessing fields by their full names. For instance, you can access the checkbox labeled Gain de 2 classes using its full name Gain de 2 classes.0 instead of its partial name 0 . NOTE: When using full names, the update_widget_key and commit_widget_key_updates methods of PdfWrapper are disabled and raise a NotImplementedError because full names involve both the field and its parent.","title":"Use full name for PDF form fields"},{"location":"install/#write-to-a-file","text":"PdfWrapper behaves like an open file object, allowing you to write the PDF to another file object. For example, to write to a disk file: from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\") with open(\"output.pdf\", \"wb+\") as output: output.write(pdf.read()) It doesn't have to be a disk file; it can be a memory buffer as well: from io import BytesIO from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\") with BytesIO() as output: output.write(pdf.read()) In addition to behaving like a file object, PdfWrapper also implements a write method that allows you to write the PDF to a disk file by specifying the path: from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\") pdf.write(\"output.pdf\")","title":"Write to a file"},{"location":"prepare/","text":"Create form fields The most common tool for creating PDF form fields is Adobe Acrobat, and a tutorial is available here . Alternative free tools like DocFly offer similar functionality. PyPDFForm also allows creating PDF form fields on existing PDFs through coding. This section of the documentation will primarily use this PDF as an example. Understanding the PDF coordinate system is necessary for this section. All optional parameters will have a comment # optional after each of them. Create a text field A text field can be created by downloading the PDF and running the following snippet: from PyPDFForm import Fields, PdfWrapper new_form = PdfWrapper(\"dummy.pdf\").create_field( Fields.TextField( name=\"new_text_field\", page_number=1, x=57.5, y=700.9, required=False, # optional tooltip=\"this is a text field\", # optional width=120.3, # optional height=40.7, # optional max_length=5, # optional, number of characters comb=True, # optional, when set to True, max_length must also be set font=\"your_registered_font\", # optional font_size=15, # optional font_color=(1, 0, 0), # optional bg_color=(0, 0, 1, 1), # optional, (r, g, b, alpha) border_color=(1, 0, 0, 1), # optional, (r, g, b, alpha) border_width=5, # optional alignment=0, # optional, 0=left, 1=center, 2=right multiline=True, # optional ) ) new_form.write(\"output.pdf\") To use a custom font, see how to register it here . NOTE: For the comb option, refer to the documentation here . Create a checkbox A checkbox can be created using the same method with some changes to the parameters: from PyPDFForm import Fields, PdfWrapper new_form = PdfWrapper(\"dummy.pdf\").create_field( Fields.CheckBoxField( name=\"new_checkbox\", page_number=1, x=57, y=700, required=False, # optional tooltip=\"this is a checkbox\", # optional size=30, # optional button_style=\"check\", # optional tick_color=(0, 1, 0), # optional bg_color=(0, 0, 1, 1), # optional, (r, g, b, alpha) border_color=(1, 0, 0, 1), # optional, (r, g, b, alpha) border_width=5, # optional ) ) new_form.write(\"output.pdf\") The button_style parameter currently supports three options: check , circle , and cross . NOTE: To remove the border of a checkbox, set the alpha channel of the border_color to 0, for example: border_color=(1, 0, 0, 0) . Setting border_width to 0 may still render a border with a width of 1 due to a PDF specification quirk. Create a radio button group Unlike other field types, radio buttons must be created as a group. Therefore, for the coordinate parameters x and y , you must specify a list of coordinates for each radio button within the group, and the list must contain more than one coordinate. Otherwise, radio button creation shares almost the same parameters as a checkbox: from PyPDFForm import Fields, PdfWrapper new_form = PdfWrapper(\"dummy.pdf\").create_field( Fields.RadioGroup( name=\"new_radio_group\", page_number=1, x=[50, 100, 150], y=[50, 100, 150], required=False, # optional tooltip=\"this is a radio group\", # optional size=30, # optional button_style=\"check\", # optional shape=\"square\", # optional, circle or square tick_color=(0, 1, 0), # optional bg_color=(0, 0, 1, 1), # optional, (r, g, b, alpha) border_color=(1, 0, 0, 1), # optional, (r, g, b, alpha) border_width=5, # optional ) ) new_form.write(\"output.pdf\") NOTE: To remove the border of a group of radio buttons, set the alpha channel of the border_color to 0, for example: border_color=(1, 0, 0, 0) . Setting border_width to 0 may still render a border with a width of 1 due to a PDF specification quirk. Create a dropdown field A dropdown field shares a similar set of parameters as a text field. The only significant difference is that a list of options needs to be specified: from PyPDFForm import Fields, PdfWrapper new_form = PdfWrapper(\"dummy.pdf\").create_field( Fields.DropdownField( name=\"new_dropdown\", page_number=1, x=57, y=700, options=[ \"foo\", \"bar\", \"foobar\", ], required=False, # optional tooltip=\"this is a dropdown\", # optional width=120, # optional height=40, # optional font=\"your_registered_font\", # optional font_size=15, # optional font_color=(1, 0, 0), # optional bg_color=(0, 0, 1, 1), # optional, (r, g, b, alpha) border_color=(1, 0, 0, 1), # optional, (r, g, b, alpha) border_width=5, # optional ) ) new_form.write(\"output.pdf\") To use a custom font, see how to register it here . If you want different export values from the displayed options, you can specify a list of tuples for the options parameter, where the first value of each tuple is the displayed option and the second value is the export value: from PyPDFForm import Fields, PdfWrapper new_form = PdfWrapper(\"dummy.pdf\").create_field( Fields.DropdownField( name=\"new_dropdown\", page_number=1, x=57, y=700, options=[ (\"option_1\", \"option_1_export_value\"), (\"option_2\", \"option_2_export_value\"), (\"option_3\", \"option_3_export_value\"), ], ) ) new_form.write(\"output.pdf\") Create a signature field A signature field is only interactive in tools that support it. Otherwise, it is displayed as a rectangle, and clicking it will not trigger any action: from PyPDFForm import Fields, PdfWrapper new_form = PdfWrapper(\"dummy.pdf\").create_field( Fields.SignatureField( name=\"new_signature\", page_number=1, x=100, y=100, required=False, # optional tooltip=\"this is a signature\", # optional width=410, # optional height=100, # optional ) ) new_form.write(\"output.pdf\") Create an image field Similar to a signature field, an image field is also only interactive in tools that support it: from PyPDFForm import Fields, PdfWrapper new_form = PdfWrapper(\"dummy.pdf\").create_field( Fields.ImageField( name=\"new_image\", page_number=1, x=100, y=100, required=False, # optional tooltip=\"this is an image\", # optional width=192, # optional height=108, # optional ) ) new_form.write(\"output.pdf\") Modify the key of a field PyPDFForm allows you to modify the keys of existing fields. For example, to change the key of the first text field, test , to test_text using this PDF , use the following code: from PyPDFForm import PdfWrapper new_form = PdfWrapper(\"sample_template.pdf\").update_widget_key( \"test\", \"test_text\" ) new_form.write(\"output.pdf\") If multiple fields share the same key, use the index parameter to specify which one to update. For instance, to change the key of the second row's text field with the key Description[0] to Description[1] using this PDF , use the following code: from PyPDFForm import PdfWrapper new_form = PdfWrapper(\"733.pdf\").update_widget_key( \"Description[0]\", \"Description[1]\", index=1 ) new_form.write(\"output.pdf\") For bulk updates, improve performance by setting defer=True when updating each key, then call commit_widget_key_updates() at the end to commit all changes. To change the key of each row's text field with the key Description[0] to Description[i] , where i is the index of each row, using this PDF , use the following code: from PyPDFForm import PdfWrapper new_form = PdfWrapper(\"733.pdf\") for i in range(1, 10): new_form.update_widget_key( \"Description[0]\", f\"Description[{i}]\", index=1, defer=True ) new_form.commit_widget_key_updates().write(\"output.pdf\")","title":"Create form fields"},{"location":"prepare/#create-form-fields","text":"The most common tool for creating PDF form fields is Adobe Acrobat, and a tutorial is available here . Alternative free tools like DocFly offer similar functionality. PyPDFForm also allows creating PDF form fields on existing PDFs through coding. This section of the documentation will primarily use this PDF as an example. Understanding the PDF coordinate system is necessary for this section. All optional parameters will have a comment # optional after each of them.","title":"Create form fields"},{"location":"prepare/#create-a-text-field","text":"A text field can be created by downloading the PDF and running the following snippet: from PyPDFForm import Fields, PdfWrapper new_form = PdfWrapper(\"dummy.pdf\").create_field( Fields.TextField( name=\"new_text_field\", page_number=1, x=57.5, y=700.9, required=False, # optional tooltip=\"this is a text field\", # optional width=120.3, # optional height=40.7, # optional max_length=5, # optional, number of characters comb=True, # optional, when set to True, max_length must also be set font=\"your_registered_font\", # optional font_size=15, # optional font_color=(1, 0, 0), # optional bg_color=(0, 0, 1, 1), # optional, (r, g, b, alpha) border_color=(1, 0, 0, 1), # optional, (r, g, b, alpha) border_width=5, # optional alignment=0, # optional, 0=left, 1=center, 2=right multiline=True, # optional ) ) new_form.write(\"output.pdf\") To use a custom font, see how to register it here . NOTE: For the comb option, refer to the documentation here .","title":"Create a text field"},{"location":"prepare/#create-a-checkbox","text":"A checkbox can be created using the same method with some changes to the parameters: from PyPDFForm import Fields, PdfWrapper new_form = PdfWrapper(\"dummy.pdf\").create_field( Fields.CheckBoxField( name=\"new_checkbox\", page_number=1, x=57, y=700, required=False, # optional tooltip=\"this is a checkbox\", # optional size=30, # optional button_style=\"check\", # optional tick_color=(0, 1, 0), # optional bg_color=(0, 0, 1, 1), # optional, (r, g, b, alpha) border_color=(1, 0, 0, 1), # optional, (r, g, b, alpha) border_width=5, # optional ) ) new_form.write(\"output.pdf\") The button_style parameter currently supports three options: check , circle , and cross . NOTE: To remove the border of a checkbox, set the alpha channel of the border_color to 0, for example: border_color=(1, 0, 0, 0) . Setting border_width to 0 may still render a border with a width of 1 due to a PDF specification quirk.","title":"Create a checkbox"},{"location":"prepare/#create-a-radio-button-group","text":"Unlike other field types, radio buttons must be created as a group. Therefore, for the coordinate parameters x and y , you must specify a list of coordinates for each radio button within the group, and the list must contain more than one coordinate. Otherwise, radio button creation shares almost the same parameters as a checkbox: from PyPDFForm import Fields, PdfWrapper new_form = PdfWrapper(\"dummy.pdf\").create_field( Fields.RadioGroup( name=\"new_radio_group\", page_number=1, x=[50, 100, 150], y=[50, 100, 150], required=False, # optional tooltip=\"this is a radio group\", # optional size=30, # optional button_style=\"check\", # optional shape=\"square\", # optional, circle or square tick_color=(0, 1, 0), # optional bg_color=(0, 0, 1, 1), # optional, (r, g, b, alpha) border_color=(1, 0, 0, 1), # optional, (r, g, b, alpha) border_width=5, # optional ) ) new_form.write(\"output.pdf\") NOTE: To remove the border of a group of radio buttons, set the alpha channel of the border_color to 0, for example: border_color=(1, 0, 0, 0) . Setting border_width to 0 may still render a border with a width of 1 due to a PDF specification quirk.","title":"Create a radio button group"},{"location":"prepare/#create-a-dropdown-field","text":"A dropdown field shares a similar set of parameters as a text field. The only significant difference is that a list of options needs to be specified: from PyPDFForm import Fields, PdfWrapper new_form = PdfWrapper(\"dummy.pdf\").create_field( Fields.DropdownField( name=\"new_dropdown\", page_number=1, x=57, y=700, options=[ \"foo\", \"bar\", \"foobar\", ], required=False, # optional tooltip=\"this is a dropdown\", # optional width=120, # optional height=40, # optional font=\"your_registered_font\", # optional font_size=15, # optional font_color=(1, 0, 0), # optional bg_color=(0, 0, 1, 1), # optional, (r, g, b, alpha) border_color=(1, 0, 0, 1), # optional, (r, g, b, alpha) border_width=5, # optional ) ) new_form.write(\"output.pdf\") To use a custom font, see how to register it here . If you want different export values from the displayed options, you can specify a list of tuples for the options parameter, where the first value of each tuple is the displayed option and the second value is the export value: from PyPDFForm import Fields, PdfWrapper new_form = PdfWrapper(\"dummy.pdf\").create_field( Fields.DropdownField( name=\"new_dropdown\", page_number=1, x=57, y=700, options=[ (\"option_1\", \"option_1_export_value\"), (\"option_2\", \"option_2_export_value\"), (\"option_3\", \"option_3_export_value\"), ], ) ) new_form.write(\"output.pdf\")","title":"Create a dropdown field"},{"location":"prepare/#create-a-signature-field","text":"A signature field is only interactive in tools that support it. Otherwise, it is displayed as a rectangle, and clicking it will not trigger any action: from PyPDFForm import Fields, PdfWrapper new_form = PdfWrapper(\"dummy.pdf\").create_field( Fields.SignatureField( name=\"new_signature\", page_number=1, x=100, y=100, required=False, # optional tooltip=\"this is a signature\", # optional width=410, # optional height=100, # optional ) ) new_form.write(\"output.pdf\")","title":"Create a signature field"},{"location":"prepare/#create-an-image-field","text":"Similar to a signature field, an image field is also only interactive in tools that support it: from PyPDFForm import Fields, PdfWrapper new_form = PdfWrapper(\"dummy.pdf\").create_field( Fields.ImageField( name=\"new_image\", page_number=1, x=100, y=100, required=False, # optional tooltip=\"this is an image\", # optional width=192, # optional height=108, # optional ) ) new_form.write(\"output.pdf\")","title":"Create an image field"},{"location":"prepare/#modify-the-key-of-a-field","text":"PyPDFForm allows you to modify the keys of existing fields. For example, to change the key of the first text field, test , to test_text using this PDF , use the following code: from PyPDFForm import PdfWrapper new_form = PdfWrapper(\"sample_template.pdf\").update_widget_key( \"test\", \"test_text\" ) new_form.write(\"output.pdf\") If multiple fields share the same key, use the index parameter to specify which one to update. For instance, to change the key of the second row's text field with the key Description[0] to Description[1] using this PDF , use the following code: from PyPDFForm import PdfWrapper new_form = PdfWrapper(\"733.pdf\").update_widget_key( \"Description[0]\", \"Description[1]\", index=1 ) new_form.write(\"output.pdf\") For bulk updates, improve performance by setting defer=True when updating each key, then call commit_widget_key_updates() at the end to commit all changes. To change the key of each row's text field with the key Description[0] to Description[i] , where i is the index of each row, using this PDF , use the following code: from PyPDFForm import PdfWrapper new_form = PdfWrapper(\"733.pdf\") for i in range(1, 10): new_form.update_widget_key( \"Description[0]\", f\"Description[{i}]\", index=1, defer=True ) new_form.commit_widget_key_updates().write(\"output.pdf\")","title":"Modify the key of a field"},{"location":"style/","text":"Change form field styles PyPDFForm enables you to modify some field styles through code, allowing you to change field appearances without altering the PDF form template. This section of the documentation will primarily use this PDF as an example. Change text field font Before changing a text field's font, you must first register the desired font. After registration, you can apply the registered font to any text field: from PyPDFForm import PdfWrapper, Text form = PdfWrapper(\"sample_template.pdf\") # change globally by iterating each text field for field in form.widgets.values(): if isinstance(field, Text): field.font = \"your_registered_font\" # or change at each field's widget level form.widgets[\"test\"].font = \"your_registered_font\" form.fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) form.write(\"output.pdf\") Change text field font size You can change the font size using a float value in PyPDFForm: from PyPDFForm import PdfWrapper, Text form = PdfWrapper(\"sample_template.pdf\") # change globally by iterating each text field for field in form.widgets.values(): if isinstance(field, Text): field.font_size = 20 # or change at each field's widget level form.widgets[\"test\"].font_size = 30.5 form.fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) form.write(\"output.pdf\") Change text field font color You can change the font color using an RGB tuple : from PyPDFForm import PdfWrapper, Text form = PdfWrapper(\"sample_template.pdf\") # change globally by iterating each text field for field in form.widgets.values(): if isinstance(field, Text): field.font_color = (1, 0, 0) # or change at each field's widget level form.widgets[\"test\"].font_color = (0.2, 0, 0.5) form.fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) form.write(\"output.pdf\") Change text field alignment You can change the alignment of the text filled into a text field by setting its alignment property to an integer value: 0 for left, 1 for center, and 2 for right. from PyPDFForm import PdfWrapper, Text form = PdfWrapper(\"sample_template.pdf\") # change globally by iterating each text field for field in form.widgets.values(): if isinstance(field, Text): field.alignment = 1 # center # or change at each field's widget level form.widgets[\"test\"].alignment = 2 # right form.fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) form.write(\"output.pdf\") Change text field max length You can change the maximum number of characters allowed in a text field: from PyPDFForm import PdfWrapper, Text form = PdfWrapper(\"sample_template.pdf\") # change globally by iterating each text field for field in form.widgets.values(): if isinstance(field, Text): field.max_length = 4 # or change at each field's widget level form.widgets[\"test\"].max_length = 2 form.fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) form.write(\"output.pdf\") Enable text field character spacing (combs) To enable character spacing in a text field, set its .comb property to True . This will evenly space out the characters of the text filled into the field. Note that this property only takes effect when the text field also has a max_length set. from PyPDFForm import PdfWrapper, Text form = PdfWrapper(\"sample_template.pdf\") # change globally by iterating each text field for field in form.widgets.values(): if isinstance(field, Text): field.max_length = 4 field.comb = True # or change at each field's widget level form.widgets[\"test\"].max_length = 2 form.widgets[\"test\"].comb = True form.fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) form.write(\"output.pdf\") Enable multiline text field To enable multiline input for a text field, set its .multiline property to True . This effectively transforms it into a paragraph field: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template.pdf\") form.widgets[\"test\"].multiline = True form.fill( { \"test\": \"test_1\\ntest_1\", \"check\": True, \"test_2\": \"test_2\\ntest_2\", \"check_2\": False, \"test_3\": \"test_3\\ntest_3\", \"check_3\": True, }, ) form.write(\"output.pdf\") Change checkbox/radio button size You can change the size of a checkbox or a group of radio buttons using a float value: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template.pdf\") form.widgets[\"check\"].size = 50 form.widgets[\"check_2\"].size = 40 form.widgets[\"check_3\"].size = 60 form.fill( { \"check\": True, \"check_2\": True, \"check_3\": True, }, ) form.write(\"output.pdf\") Change dropdown field choices To modify the options available in a dropdown field, assign a new list of strings to the .choices attribute of the corresponding field. For instance, the following code snippet updates the dropdown_1 field in this PDF form with a new set of choices: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template_with_dropdown.pdf\") form.widgets[\"dropdown_1\"].choices = [\"\", \"apple\", \"banana\", \"cherry\", \"dates\"] form.write(\"output.pdf\") If you want different export values from the displayed options, you can specify a list of tuples for the .choices attribute, where the first value of each tuple is the displayed option and the second value is the export value: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template_with_dropdown.pdf\") form.widgets[\"dropdown_1\"].choices = [ (\"\", \"blank_export_value\"), (\"apple\", \"apple_export_value\"), (\"banana\", \"banana_export_value\"), (\"cherry\", \"cherry_export_value\"), (\"dates\", \"dates_export_value\"), ] form.write(\"output.pdf\") Change dropdown field font Before changing a dropdown field's font, you must first register the desired font. After registration, you can apply the registered font to any dropdown field: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template_with_dropdown.pdf\") form.widgets[\"dropdown_1\"].font = \"your_registered_font\" form.write(\"output.pdf\") Change dropdown field font size You can change a dropdown field's font size using a float value in PyPDFForm: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template_with_dropdown.pdf\") form.widgets[\"dropdown_1\"].font_size = 30 form.write(\"output.pdf\") Change dropdown field font color You can change a dropdown field's font color using an RGB tuple : from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template_with_dropdown.pdf\") form.widgets[\"dropdown_1\"].font_color = (1, 0, 0) form.write(\"output.pdf\") Change field editability The readonly property of each form field controls its editability. Setting readonly to True flattens the field, making it uneditable, while setting it to False unflattens it, making it editable. For example, the following code snippet shows how you can make different form fields editable in this PDF form after they have been flattened: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template_with_dropdown.pdf\") form.fill( { \"test_1\": \"test_1\", \"test_2\": \"test_2\", \"test_3\": \"test_3\", \"check_1\": True, \"check_2\": True, \"check_3\": True, \"radio_1\": 1, \"dropdown_1\": 0, }, flatten=True, ) form.widgets[\"test_2\"].readonly = False # text form.widgets[\"check_3\"].readonly = False # checkbox form.widgets[\"radio_1\"].readonly = False # radio button group form.widgets[\"dropdown_1\"].readonly = False # dropdown form.write(\"output.pdf\")","title":"Change form field styles"},{"location":"style/#change-form-field-styles","text":"PyPDFForm enables you to modify some field styles through code, allowing you to change field appearances without altering the PDF form template. This section of the documentation will primarily use this PDF as an example.","title":"Change form field styles"},{"location":"style/#change-text-field-font","text":"Before changing a text field's font, you must first register the desired font. After registration, you can apply the registered font to any text field: from PyPDFForm import PdfWrapper, Text form = PdfWrapper(\"sample_template.pdf\") # change globally by iterating each text field for field in form.widgets.values(): if isinstance(field, Text): field.font = \"your_registered_font\" # or change at each field's widget level form.widgets[\"test\"].font = \"your_registered_font\" form.fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) form.write(\"output.pdf\")","title":"Change text field font"},{"location":"style/#change-text-field-font-size","text":"You can change the font size using a float value in PyPDFForm: from PyPDFForm import PdfWrapper, Text form = PdfWrapper(\"sample_template.pdf\") # change globally by iterating each text field for field in form.widgets.values(): if isinstance(field, Text): field.font_size = 20 # or change at each field's widget level form.widgets[\"test\"].font_size = 30.5 form.fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) form.write(\"output.pdf\")","title":"Change text field font size"},{"location":"style/#change-text-field-font-color","text":"You can change the font color using an RGB tuple : from PyPDFForm import PdfWrapper, Text form = PdfWrapper(\"sample_template.pdf\") # change globally by iterating each text field for field in form.widgets.values(): if isinstance(field, Text): field.font_color = (1, 0, 0) # or change at each field's widget level form.widgets[\"test\"].font_color = (0.2, 0, 0.5) form.fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) form.write(\"output.pdf\")","title":"Change text field font color"},{"location":"style/#change-text-field-alignment","text":"You can change the alignment of the text filled into a text field by setting its alignment property to an integer value: 0 for left, 1 for center, and 2 for right. from PyPDFForm import PdfWrapper, Text form = PdfWrapper(\"sample_template.pdf\") # change globally by iterating each text field for field in form.widgets.values(): if isinstance(field, Text): field.alignment = 1 # center # or change at each field's widget level form.widgets[\"test\"].alignment = 2 # right form.fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) form.write(\"output.pdf\")","title":"Change text field alignment"},{"location":"style/#change-text-field-max-length","text":"You can change the maximum number of characters allowed in a text field: from PyPDFForm import PdfWrapper, Text form = PdfWrapper(\"sample_template.pdf\") # change globally by iterating each text field for field in form.widgets.values(): if isinstance(field, Text): field.max_length = 4 # or change at each field's widget level form.widgets[\"test\"].max_length = 2 form.fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) form.write(\"output.pdf\")","title":"Change text field max length"},{"location":"style/#enable-text-field-character-spacing-combs","text":"To enable character spacing in a text field, set its .comb property to True . This will evenly space out the characters of the text filled into the field. Note that this property only takes effect when the text field also has a max_length set. from PyPDFForm import PdfWrapper, Text form = PdfWrapper(\"sample_template.pdf\") # change globally by iterating each text field for field in form.widgets.values(): if isinstance(field, Text): field.max_length = 4 field.comb = True # or change at each field's widget level form.widgets[\"test\"].max_length = 2 form.widgets[\"test\"].comb = True form.fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) form.write(\"output.pdf\")","title":"Enable text field character spacing (combs)"},{"location":"style/#enable-multiline-text-field","text":"To enable multiline input for a text field, set its .multiline property to True . This effectively transforms it into a paragraph field: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template.pdf\") form.widgets[\"test\"].multiline = True form.fill( { \"test\": \"test_1\\ntest_1\", \"check\": True, \"test_2\": \"test_2\\ntest_2\", \"check_2\": False, \"test_3\": \"test_3\\ntest_3\", \"check_3\": True, }, ) form.write(\"output.pdf\")","title":"Enable multiline text field"},{"location":"style/#change-checkboxradio-button-size","text":"You can change the size of a checkbox or a group of radio buttons using a float value: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template.pdf\") form.widgets[\"check\"].size = 50 form.widgets[\"check_2\"].size = 40 form.widgets[\"check_3\"].size = 60 form.fill( { \"check\": True, \"check_2\": True, \"check_3\": True, }, ) form.write(\"output.pdf\")","title":"Change checkbox/radio button size"},{"location":"style/#change-dropdown-field-choices","text":"To modify the options available in a dropdown field, assign a new list of strings to the .choices attribute of the corresponding field. For instance, the following code snippet updates the dropdown_1 field in this PDF form with a new set of choices: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template_with_dropdown.pdf\") form.widgets[\"dropdown_1\"].choices = [\"\", \"apple\", \"banana\", \"cherry\", \"dates\"] form.write(\"output.pdf\") If you want different export values from the displayed options, you can specify a list of tuples for the .choices attribute, where the first value of each tuple is the displayed option and the second value is the export value: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template_with_dropdown.pdf\") form.widgets[\"dropdown_1\"].choices = [ (\"\", \"blank_export_value\"), (\"apple\", \"apple_export_value\"), (\"banana\", \"banana_export_value\"), (\"cherry\", \"cherry_export_value\"), (\"dates\", \"dates_export_value\"), ] form.write(\"output.pdf\")","title":"Change dropdown field choices"},{"location":"style/#change-dropdown-field-font","text":"Before changing a dropdown field's font, you must first register the desired font. After registration, you can apply the registered font to any dropdown field: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template_with_dropdown.pdf\") form.widgets[\"dropdown_1\"].font = \"your_registered_font\" form.write(\"output.pdf\")","title":"Change dropdown field font"},{"location":"style/#change-dropdown-field-font-size","text":"You can change a dropdown field's font size using a float value in PyPDFForm: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template_with_dropdown.pdf\") form.widgets[\"dropdown_1\"].font_size = 30 form.write(\"output.pdf\")","title":"Change dropdown field font size"},{"location":"style/#change-dropdown-field-font-color","text":"You can change a dropdown field's font color using an RGB tuple : from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template_with_dropdown.pdf\") form.widgets[\"dropdown_1\"].font_color = (1, 0, 0) form.write(\"output.pdf\")","title":"Change dropdown field font color"},{"location":"style/#change-field-editability","text":"The readonly property of each form field controls its editability. Setting readonly to True flattens the field, making it uneditable, while setting it to False unflattens it, making it editable. For example, the following code snippet shows how you can make different form fields editable in this PDF form after they have been flattened: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template_with_dropdown.pdf\") form.fill( { \"test_1\": \"test_1\", \"test_2\": \"test_2\", \"test_3\": \"test_3\", \"check_1\": True, \"check_2\": True, \"check_3\": True, \"radio_1\": 1, \"dropdown_1\": 0, }, flatten=True, ) form.widgets[\"test_2\"].readonly = False # text form.widgets[\"check_3\"].readonly = False # checkbox form.widgets[\"radio_1\"].readonly = False # radio button group form.widgets[\"dropdown_1\"].readonly = False # dropdown form.write(\"output.pdf\")","title":"Change field editability"},{"location":"utils/","text":"Other utilities PyPDFForm offers additional utilities similar to other PDF libraries. This section of the documentation uses this PDF as an example. Extract pages The PdfWrapper object has a .pages attribute, which is a list of PdfWrapper objects representing individual pages: from PyPDFForm import PdfWrapper first_page = PdfWrapper(\"sample_template.pdf\").pages[0] first_page.fill( { \"test\": \"test_1\", \"check\": True, }, ) first_page.write(\"output.pdf\") Merge multiple PDFs You can merge multiple PDF files by adding their PdfWrapper objects. For example, to merge this PDF and this PDF : from PyPDFForm import PdfWrapper pdf_one = PdfWrapper(\"dummy.pdf\") pdf_two = PdfWrapper(\"sample_template.pdf\") merged = pdf_one + pdf_two merged.write(\"output.pdf\") To reorganize pages: from PyPDFForm import PdfWrapper pdf_one = PdfWrapper(\"dummy.pdf\") pdf_two = PdfWrapper(\"sample_template.pdf\") merged = pdf_two.pages[0] + pdf_one + pdf_two.pages[1] + pdf_two.pages[2] merged.write(\"output.pdf\") Change PDF version PyPDFForm allows you to modify the PDF version up to 2.0: from PyPDFForm import PdfWrapper new_version = PdfWrapper(\"sample_template.pdf\").change_version(\"2.0\") new_version.write(\"output.pdf\")","title":"Other utilities"},{"location":"utils/#other-utilities","text":"PyPDFForm offers additional utilities similar to other PDF libraries. This section of the documentation uses this PDF as an example.","title":"Other utilities"},{"location":"utils/#extract-pages","text":"The PdfWrapper object has a .pages attribute, which is a list of PdfWrapper objects representing individual pages: from PyPDFForm import PdfWrapper first_page = PdfWrapper(\"sample_template.pdf\").pages[0] first_page.fill( { \"test\": \"test_1\", \"check\": True, }, ) first_page.write(\"output.pdf\")","title":"Extract pages"},{"location":"utils/#merge-multiple-pdfs","text":"You can merge multiple PDF files by adding their PdfWrapper objects. For example, to merge this PDF and this PDF : from PyPDFForm import PdfWrapper pdf_one = PdfWrapper(\"dummy.pdf\") pdf_two = PdfWrapper(\"sample_template.pdf\") merged = pdf_one + pdf_two merged.write(\"output.pdf\") To reorganize pages: from PyPDFForm import PdfWrapper pdf_one = PdfWrapper(\"dummy.pdf\") pdf_two = PdfWrapper(\"sample_template.pdf\") merged = pdf_two.pages[0] + pdf_one + pdf_two.pages[1] + pdf_two.pages[2] merged.write(\"output.pdf\")","title":"Merge multiple PDFs"},{"location":"utils/#change-pdf-version","text":"PyPDFForm allows you to modify the PDF version up to 2.0: from PyPDFForm import PdfWrapper new_version = PdfWrapper(\"sample_template.pdf\").change_version(\"2.0\") new_version.write(\"output.pdf\")","title":"Change PDF version"},{"location":"news/2024-01-01/","text":"2024-01-01: API Changes Happy new year fellow developers! We start the year 2024 with a new release of v1.4.0 and there are some important changes I'm making to the APIs of the library. The PDF object that gets instantiated is now PyPDFForm.PdfWrapper , changed from PyPDFForm.PyPDFForm . Form widgets are now accessed via the PdfWrapper.widgets attribute, changed from PdfWrapper.elements . The JSON schema of the form data is now accessed via a new attribute called PdfWrapper.schema , changed from the old method of PdfWrapper.generate_schema() . All the old APIs will be persisted for half a year and then fully deprecated. Each of them will emit a DeprecationWarning when invoked, so it is advised that you make the switch before they are removed and start breaking your code. Happy hacking!","title":"2024-01-01: API Changes"},{"location":"news/2024-01-01/#2024-01-01-api-changes","text":"Happy new year fellow developers! We start the year 2024 with a new release of v1.4.0 and there are some important changes I'm making to the APIs of the library. The PDF object that gets instantiated is now PyPDFForm.PdfWrapper , changed from PyPDFForm.PyPDFForm . Form widgets are now accessed via the PdfWrapper.widgets attribute, changed from PdfWrapper.elements . The JSON schema of the form data is now accessed via a new attribute called PdfWrapper.schema , changed from the old method of PdfWrapper.generate_schema() . All the old APIs will be persisted for half a year and then fully deprecated. Each of them will emit a DeprecationWarning when invoked, so it is advised that you make the switch before they are removed and start breaking your code. Happy hacking!","title":"2024-01-01: API Changes"},{"location":"news/2025-03-29/","text":"2025-03-29: Announcements Hello fellow Python developers! With the release of v2.0.0, there are some important changes I'm making to the library: Since I started developing the library, versioning releases has been quite unorthodox, and there isn't any convention I followed. Starting with v2.0.0, PyPDFForm will version releases following the conventions defined by Semantic Versioning . PyPDFForm now renders PDF form widgets! Ever since its ancestral stage, the library has only been able to render the data you filled into a PDF form. Now if you fill a PDF form using PdfWrapper , the result will render the whole widget instead of just the value that got filled. If you would like to disable this behavior, please refer to the docs here . Happy hacking!","title":"2025-03-29: Announcements"},{"location":"news/2025-03-29/#2025-03-29-announcements","text":"Hello fellow Python developers! With the release of v2.0.0, there are some important changes I'm making to the library: Since I started developing the library, versioning releases has been quite unorthodox, and there isn't any convention I followed. Starting with v2.0.0, PyPDFForm will version releases following the conventions defined by Semantic Versioning . PyPDFForm now renders PDF form widgets! Ever since its ancestral stage, the library has only been able to render the data you filled into a PDF form. Now if you fill a PDF form using PdfWrapper , the result will render the whole widget instead of just the value that got filled. If you would like to disable this behavior, please refer to the docs here . Happy hacking!","title":"2025-03-29: Announcements"},{"location":"news/2025-05-24/","text":"2025-05-24: V3 Announcements This article provides important information about the upcoming v3.0.0 release. TL; DR PyPDFForm v3.0.0 is scheduled for release on June 24, 2025. This major release includes changes that will break compatibility with older code. To avoid issues, pin your version to <=2.5.0 as soon as possible. Here's a list of the changes: FormWrapper has been removed. Its features have been moved to PdfWrapper . The fill method of PdfWrapper will now work the same way it did in FormWrapper . The way to enable adobe_mode when filling has changed. Instead of passing adobe_mode as an argument to the fill method, you now pass it when creating a PdfWrapper object. Setting font properties for the entire document (e.g., PdfWrapper(\"sample_template.pdf\", global_font_size=20) ) is no longer supported. You must now set font properties for each individual widget. register_font is now a method of the PdfWrapper object, not a general class method. PdfWrapper.preview is removed. You can no longer change the button_style of existing checkboxes or radio buttons. (Setting the button_style when you create them is still supported.) Render widgets flag render_widgets is removed. Why these changes? When I started this project about five years ago, I didn't have as much experience as I do now. I ran into some technical problems during the initial proof of concept. One problem was that filled text fields in Adobe Acrobat sometimes only appeared when the field was selected. Because of this behavior in Adobe Acrobat, and because I wanted to support as many PDF viewers as possible, I decided to use a \"watermark\" approach. Instead of directly changing the form field data, this approach gathers information about each field, such as its location, font, size, and color. Then, it removes all the original form fields, creates a watermark of the PDF, draws the filled content onto the watermark, and combines the watermark with the original PDF. Even though this removes the original fields and makes the filled content look \"flattened\", it ensures that the filled PDFs only contain basic PDF data and can be viewed in any PDF application. The project has grown since then, adding features like custom form field styles and even the ability to create form fields. As of version 2.5.0, the PdfWrapper still uses this watermark method as its core. About a year ago, with the help of the community, I was finally able to solve the text field issue in Adobe Acrobat that had been present since the beginning of the project. This made it possible to directly modify the form field data when filling a PDF, which has several benefits: the form fields can remain editable after filling, there's no need for complicated calculations to determine coordinates and resolutions, and merging watermarks with the original PDF is no longer necessary, which greatly improves performance. However, the project had already developed significantly, and some features that relied on the watermark approach, such as changing font properties, couldn't be easily adapted to the new method, at least not initially. Therefore, instead of completely abandoning the watermark approach, I decided to create a new, simpler set of APIs that would support this new way of filling forms. This resulted in the FormWrapper . The FormWrapper turned out to be a good addition, attracting even more users because it could truly \"fill\" a PDF form as if it were done by hand. Since then, PdfWrapper and FormWrapper have existed side-by-side. However, recent developments have made it necessary to introduce even more significant and fundamental changes to the project. First, I've noticed that many users, even when using features from PdfWrapper like creating or renaming widgets, prefer to use FormWrapper for the final step of filling the PDF. In these situations, I've had to advise them to first perform the necessary actions with PdfWrapper , extract the stream from the PdfWrapper object, and then use that as input for FormWrapper to complete the filling process. This workflow doesn't seem very intuitive. Second, I've developed some extremely complex calculations to determine how form field data should be drawn when using the watermark method. However, I've reached a point where I can't figure out how to support landscape PDFs due to orientation issues. This makes abandoning the watermark approach even more desirable. Finally, my recent research has revealed clearer ways to implement features that were previously only achievable through the watermark method by directly manipulating form field data. Considering everything mentioned above, I believe it's time to introduce the next major version of PyPDFForm: v3.0.0. What are the changes? In short, the goal of v3.0.0 can be summed up to: Merge FormWrapper into PdfWrapper . Reimplement most, if not all, PdfWrapper features, especially the fill method, by directly manipulating form field data. Preserve as much backward compatibility as possible. Let's talk more about backward compatibility. With changes as significant as those in this release, it's impossible to maintain complete backward compatibility. For instance, even if you use the fill method in the same way as before, the filled PDF forms will now be editable because the watermark method is no longer used. So, when I say I've tried to preserve as much backward compatibility as possible, I mean I've minimized the number of API changes. The appearance of your generated PDFs will be slightly different compared to the watermark approach, but you'll still be able to use most of PyPDFForm's APIs in the same way as before the release. However, some unavoidable changes will break backward compatibility. This is why this release is a major version update, as defined by Semantic Versioning. I'll do my best to explain these changes and the reasons behind them in the list below: As mentioned earlier, FormWrapper has been merged into PdfWrapper and completely removed. FormWrapper only provided basic PDF form filling features. After the merge, the fill method of PdfWrapper will function identically to how it did in FormWrapper . The adobe_mode parameter has been moved from the fill method to the PdfWrapper object's constructor. This change is necessary because most PdfWrapper features now directly manipulate form field data and need to support Adobe Acrobat. Therefore, the setting applies to the entire object rather than just the filling method. Previously, font properties could be set globally for each object using parameters like global_font , global_font_size , and global_font_color when creating the object. This is no longer possible. Font properties must now be set for each individual widget. Setting font properties globally made sense when they all needed to be applied to the same watermarks. Now that the project directly manipulates form fields, it's more logical to set them at the widget level. register_font is now a method that belongs to each PdfWrapper object, rather than a general class method. This change should have been made earlier, and it's becoming more obvious with this release, as each registered font should only be used for a single PDF form. The preview feature has been removed. It was initially an experimental feature and has proven to create messy, unreadable previews for PDFs with many fields. There are better ways to inspect a PDF form, such as using schema and sample_data . Modifying the button_style of existing checkboxes or radio buttons by directly manipulating form field data is difficult, as it involves complex stream creation that I'm currently unable to implement. Therefore, this feature has been removed for now but may be added back in the future. Note that this change doesn't affect the ability to set the button_style when creating checkboxes or radio buttons. render_widgets has been removed. This feature was originally added to maintain backward compatibility when the watermark approach first began supporting the rendering of widget borders and backgrounds. Since the watermark approach is no longer used, this feature is unnecessary. What do you need to do? First, I strongly recommend that you pin your PyPDFForm dependency version to <=2.5.0 as soon as possible, unless you're certain that these changes won't cause any problems for you. After pinning your version, you have a couple of options: If any of the backward-incompatible changes affect your code, update your code accordingly, using the information provided above. If you prefer the old watermark approach, you can keep your version pinned to <=2.5.0 indefinitely, as those older versions will remain available. Otherwise, once the release is made, you should have no problem upgrading to v3.0.0 and any future patches after the release. When will this happen? This announcement was written and should be published on May 24, 2025. After publication, the community will have one month to review this information and make any necessary adjustments. Therefore, unless there's significant opposition from the community, PyPDFForm v3.0.0 will be released on June 24, 2025.","title":"2025-05-24: V3 Announcements"},{"location":"news/2025-05-24/#2025-05-24-v3-announcements","text":"This article provides important information about the upcoming v3.0.0 release.","title":"2025-05-24: V3 Announcements"},{"location":"news/2025-05-24/#tl-dr","text":"PyPDFForm v3.0.0 is scheduled for release on June 24, 2025. This major release includes changes that will break compatibility with older code. To avoid issues, pin your version to <=2.5.0 as soon as possible. Here's a list of the changes: FormWrapper has been removed. Its features have been moved to PdfWrapper . The fill method of PdfWrapper will now work the same way it did in FormWrapper . The way to enable adobe_mode when filling has changed. Instead of passing adobe_mode as an argument to the fill method, you now pass it when creating a PdfWrapper object. Setting font properties for the entire document (e.g., PdfWrapper(\"sample_template.pdf\", global_font_size=20) ) is no longer supported. You must now set font properties for each individual widget. register_font is now a method of the PdfWrapper object, not a general class method. PdfWrapper.preview is removed. You can no longer change the button_style of existing checkboxes or radio buttons. (Setting the button_style when you create them is still supported.) Render widgets flag render_widgets is removed.","title":"TL; DR"},{"location":"news/2025-05-24/#why-these-changes","text":"When I started this project about five years ago, I didn't have as much experience as I do now. I ran into some technical problems during the initial proof of concept. One problem was that filled text fields in Adobe Acrobat sometimes only appeared when the field was selected. Because of this behavior in Adobe Acrobat, and because I wanted to support as many PDF viewers as possible, I decided to use a \"watermark\" approach. Instead of directly changing the form field data, this approach gathers information about each field, such as its location, font, size, and color. Then, it removes all the original form fields, creates a watermark of the PDF, draws the filled content onto the watermark, and combines the watermark with the original PDF. Even though this removes the original fields and makes the filled content look \"flattened\", it ensures that the filled PDFs only contain basic PDF data and can be viewed in any PDF application. The project has grown since then, adding features like custom form field styles and even the ability to create form fields. As of version 2.5.0, the PdfWrapper still uses this watermark method as its core. About a year ago, with the help of the community, I was finally able to solve the text field issue in Adobe Acrobat that had been present since the beginning of the project. This made it possible to directly modify the form field data when filling a PDF, which has several benefits: the form fields can remain editable after filling, there's no need for complicated calculations to determine coordinates and resolutions, and merging watermarks with the original PDF is no longer necessary, which greatly improves performance. However, the project had already developed significantly, and some features that relied on the watermark approach, such as changing font properties, couldn't be easily adapted to the new method, at least not initially. Therefore, instead of completely abandoning the watermark approach, I decided to create a new, simpler set of APIs that would support this new way of filling forms. This resulted in the FormWrapper . The FormWrapper turned out to be a good addition, attracting even more users because it could truly \"fill\" a PDF form as if it were done by hand. Since then, PdfWrapper and FormWrapper have existed side-by-side. However, recent developments have made it necessary to introduce even more significant and fundamental changes to the project. First, I've noticed that many users, even when using features from PdfWrapper like creating or renaming widgets, prefer to use FormWrapper for the final step of filling the PDF. In these situations, I've had to advise them to first perform the necessary actions with PdfWrapper , extract the stream from the PdfWrapper object, and then use that as input for FormWrapper to complete the filling process. This workflow doesn't seem very intuitive. Second, I've developed some extremely complex calculations to determine how form field data should be drawn when using the watermark method. However, I've reached a point where I can't figure out how to support landscape PDFs due to orientation issues. This makes abandoning the watermark approach even more desirable. Finally, my recent research has revealed clearer ways to implement features that were previously only achievable through the watermark method by directly manipulating form field data. Considering everything mentioned above, I believe it's time to introduce the next major version of PyPDFForm: v3.0.0.","title":"Why these changes?"},{"location":"news/2025-05-24/#what-are-the-changes","text":"In short, the goal of v3.0.0 can be summed up to: Merge FormWrapper into PdfWrapper . Reimplement most, if not all, PdfWrapper features, especially the fill method, by directly manipulating form field data. Preserve as much backward compatibility as possible. Let's talk more about backward compatibility. With changes as significant as those in this release, it's impossible to maintain complete backward compatibility. For instance, even if you use the fill method in the same way as before, the filled PDF forms will now be editable because the watermark method is no longer used. So, when I say I've tried to preserve as much backward compatibility as possible, I mean I've minimized the number of API changes. The appearance of your generated PDFs will be slightly different compared to the watermark approach, but you'll still be able to use most of PyPDFForm's APIs in the same way as before the release. However, some unavoidable changes will break backward compatibility. This is why this release is a major version update, as defined by Semantic Versioning. I'll do my best to explain these changes and the reasons behind them in the list below: As mentioned earlier, FormWrapper has been merged into PdfWrapper and completely removed. FormWrapper only provided basic PDF form filling features. After the merge, the fill method of PdfWrapper will function identically to how it did in FormWrapper . The adobe_mode parameter has been moved from the fill method to the PdfWrapper object's constructor. This change is necessary because most PdfWrapper features now directly manipulate form field data and need to support Adobe Acrobat. Therefore, the setting applies to the entire object rather than just the filling method. Previously, font properties could be set globally for each object using parameters like global_font , global_font_size , and global_font_color when creating the object. This is no longer possible. Font properties must now be set for each individual widget. Setting font properties globally made sense when they all needed to be applied to the same watermarks. Now that the project directly manipulates form fields, it's more logical to set them at the widget level. register_font is now a method that belongs to each PdfWrapper object, rather than a general class method. This change should have been made earlier, and it's becoming more obvious with this release, as each registered font should only be used for a single PDF form. The preview feature has been removed. It was initially an experimental feature and has proven to create messy, unreadable previews for PDFs with many fields. There are better ways to inspect a PDF form, such as using schema and sample_data . Modifying the button_style of existing checkboxes or radio buttons by directly manipulating form field data is difficult, as it involves complex stream creation that I'm currently unable to implement. Therefore, this feature has been removed for now but may be added back in the future. Note that this change doesn't affect the ability to set the button_style when creating checkboxes or radio buttons. render_widgets has been removed. This feature was originally added to maintain backward compatibility when the watermark approach first began supporting the rendering of widget borders and backgrounds. Since the watermark approach is no longer used, this feature is unnecessary.","title":"What are the changes?"},{"location":"news/2025-05-24/#what-do-you-need-to-do","text":"First, I strongly recommend that you pin your PyPDFForm dependency version to <=2.5.0 as soon as possible, unless you're certain that these changes won't cause any problems for you. After pinning your version, you have a couple of options: If any of the backward-incompatible changes affect your code, update your code accordingly, using the information provided above. If you prefer the old watermark approach, you can keep your version pinned to <=2.5.0 indefinitely, as those older versions will remain available. Otherwise, once the release is made, you should have no problem upgrading to v3.0.0 and any future patches after the release.","title":"What do you need to do?"},{"location":"news/2025-05-24/#when-will-this-happen","text":"This announcement was written and should be published on May 24, 2025. After publication, the community will have one month to review this information and make any necessary adjustments. Therefore, unless there's significant opposition from the community, PyPDFForm v3.0.0 will be released on June 24, 2025.","title":"When will this happen?"}]}